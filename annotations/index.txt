[Spring Boot Essentials 2 - Introdução ao curso.]:

- Explicações sobre o curso, 2 pois ja teve o 1, porém esse esta mais atualizado!
- Novos conteúdos (Exemplo: Criar uma imagem da aplicação e subir no docker);
- Overview geral sobre o curso

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 01 - O que é Spring Boot]:

- Criado pela galera da privaton, o intuito é criar app standalone (sem dependências, e iniciar rápidamente);
- O Framework toma conta de todas as configurações por nós, poucas configurações são delegadas a nós;
- Já vem com alguns servlet containers imbutidos (Tomcat, jetty, Undertow);
- O Springboot gerencia as dependências através dos Starters, possuindo uma integração forte com o ecossistema Spring;
- Ecossistema Spring: SpringBoot, Spring Framework, Spring Data, Spring Cloud, Spring Cloud Data Flow, Spring Security, dentre outros;
- Facilmente integrados com o SpringBoot (Basta incluir a dependencia no Maven ou Gradle) e realizar as chamadas;
- Um dos mais utilizados no mercado de trabalho, logo, temos bastante documentações e forums de discussões na web;
- O curso cobre o essencial para iniciar no mundo Spring, cobrindo pelomenos 70% das necessidades;

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 02 - Criando projeto na pedreiragem pt 01]:

- Sem utilizar o starter.io do Spring;
- Inicialmente o projeto inicia sem nada de frameworks (Maven e etc) apenas Java puro na versão 11;
- Add framework (Maven) criando assim o arquivo xml POM e a arvore de diretórios no src;
- Para o Spring gerenciar as dependências, devemos adicionar no pom:
Obs: Para funcionar, o maven deve estar configurado corretamente no projeto!

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
    </parent>

- Após adicionado o parent, podemos adicionar as dependências:

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>

- Para verificar todas as dependências do projeto ir em:
    Botão direito na raiz do projeto > Open Module Settings (f4) > Libraries

- Obs: Adicionamos primeiro o parent para que as dependências logo abaixo herdem as versões corretas do parent!

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 03 - Criando projeto na pedreiragem pt 02]:
Dando start na aplicação Spring WEB!

    package academy.devdojo.springboot2.start;

    import org.springframework.boot.SpringApplication;

    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

Dessa forma não funciona pois não utilizamos as anotações para tornar um Bean Spring!

- Solução 01 - Mais genérica: Utilizar a annotation @EnableAutoConfiguration

    package academy.devdojo.springboot2.start;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.EnableAutoConfiguration;

    @EnableAutoConfiguration
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

Obs: Assim a aplicação inicia em 3.838 seconds, com o Quarkus podemos otimizar e reduzir drasticamente!

---> Testando criando o primeiro Endpoint: package controller!
Utilizaremos a annotation @RestController do SpringMVC para tornar AnimeController
um Bean Spring especializado em API REST (Retornos Strings Json): CTRL + Click na annotation:
- Assinatura da annotation @RestController:

    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Controller
    @ResponseBody
    public @interface RestController {
        @AliasFor(
            annotation = Controller.class
        )
        String value() default "";
    }

- A diferença entre as anotações @RestController e @Controller é que a Rest adiciona um
@ResponseBody que indica que o retorno é uma String ou seja o Objeto Json da resposta Rest!
Diferente do @Controller que é mais genérico e não especializado em respostas Json REST

- Assinatura da annotation @Controller:

    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Component
    public @interface Controller {
        @AliasFor(
            annotation = Component.class
        )
        String value() default "";
    }

---> Caso de problemas ao utilizar classes da API JAVA mais moderna, ou aumentar o language level,
ou adicionar a dependência POM:

     <properties>
        <java.version>11</java.version>
     </properties>


---> Endpoint sem contexto: Quando não anotamos em nível de classe qual será o contexto do Endpoint:
- Obs: @RequestMapping(method = RequestMethod.GET, path = "list") está defasado/obsoleto!
- Novo jeito: @GetMapping(path="list")

    // sem Contexto:
    @RestController
    public class AnimeController {

        // Sem contexto:
        //localhost:8080/list
        @RequestMapping(method = RequestMethod.GET, path = "list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Endpoint COM contexto: Quando anotamos em nível de classe:
- Add @RequestMapping("contexto") a nível de classe:

    // COM Contexto anime:
    @RestController()
    @RequestMapping("anime") // <- ADD AQUI
    public class AnimeController {

        // COM contexto:
        //localhost:8080/anime/list
        @RequestMapping(method = RequestMethod.GET, path = "list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Utilizando o jeito novo: Substituindo @RequestMapping a nível de método para @GetMapping;

    // COM Contexto anime:
    @RestController()
    @RequestMapping("anime")
    public class AnimeController {

        // COM contexto:
        //localhost:8080/anime/list
        // Defasado/obsoleto:
    //    @RequestMapping(method = RequestMethod.GET, path = "list")
        // Novo jeito elegante:
        @GetMapping(path="list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Primeiro erro tentando acessar o Endpoint:

    Whitelabel Error Page
    This application has no explicit mapping for /error, so you are seeing this as a fallback.

    Tue May 30 14:02:32 BRT 2023
    There was an unexpected error (type=Not Found, status=404).

- Isso ocorre pois o Spring deve reconhecer TODAS as classes como um Bean para assim ele gerenciar!
- Ele reconhece isso através da hierarquia de pacotes, e se localiza pela classe "main" ApplicationStart
- Não colocamos ela na raiz, logo ele não encontra!

- Solução 01: Utilizando a anotação no ApplicationStarter.java indicando o path correto:
Utilizando o @ComponentScan(basePackages = "academy.devdojo.springboot2")

    Whitelabel Error Page
    This application has no explicit mapping for /error, so you are seeing this as a fallback.

    Tue May 30 14:13:11 BRT 2023
    There was an unexpected error (type=Internal Server Error, status=500).

- Agora o erro é outro (500): Erro de servidor, problema na serialização.
Isso ocorre geralmente por problemas de não encontrar getters and setters!
Então basta gerar os getters and setters da classe de dominio Anime (Na qual estamos gerando a List)

    [{"name":"DBZ"},{"name":"Berserk"}]

- Isso ocorre pois o Jackson que é a API especializada em Json, utiliza os métodos getters and setters
para pegar os valores e criar a response String JSON!

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 04 - @Component, @Autowired, @SpringBootApplication]:

@Autowried faz a injeção da dependência: Porém desse jeito não é recomendável por questões de segurança!
O Ideal é injetar a dependência pelos setters ou pelo construtor!
- A dependência injetada com @Autowired deve ser um Bean Spring trackeado!!
- Então devemos annotar na classe DateUtil com @Component ou Outras anotações especializadas;

    @Component
    public class DateUtil {
        ...
    }

    public class AnimeController {
        @Autowired
        private DateUtil dateUtil;
        ...
    }

- Obs: O Spring só está conseguindo trackear a classe DateUtil pois estamos escaneando tudo
apartir da raiz do projeto no ApplicationStarter.java com o
@ComponentScan(basePackages = "academy.devdojo.springboot2");
E como a classe está dentro do pacote util que está sendo trackeado, podemos realizar chamadas!

---> Movendo a classe ApplicationStarter para a raiz do projeto, assim não precisamos mais
forçar o scanner com o @ComponentScan(basePackages = "academy.devdojo.springboot2");

- Movendo para a raiz do src do projeto, não precisamos mais indicar o path no @ComponentScan()
pois ele assume como padrão o diretório em que se encontra a classe ApplicationStarter

    @EnableAutoConfiguration
    @ComponentScan
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }


---> Adicionando o Lombok no projeto para utilizar o Log4J2:
- Podemos tambem adicionar a Extensão do Lombok no projeto!

- Obs: Não indicamos a versão pois o Spring irá gerenciar isso para nós!
- Devemos habilitar na IDE o Annotation Processing;
- E se não adicionar o arquivo log4j2.xml em resources, a saída do log será apenas o valor
passado no log.info() e etc.. se quiser mais informações devemos adicionar o arquivo de
configurações log4j2.yml!! mais informações no repositório de estudos Java avançado
MaratonaJava-DevDojo no módulo JDBC (T_jdbc) aula258!
Histórico do commit com maiores detalhes:
https://github.com/WelBert-dev/MaratonaJava-DevDojo/commit/9e06ebafdac1e45420c4d6af3329041386013e80

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>


- EXEMPLO do arquivo log4j2.xml em resources:

    <?xml version="1.0" encoding="UTF-8"?>
    <Configuration status="INFO">
        <Appenders>
            <Console name="LogToConsole" target="SYSTEM_OUT">
                <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
            </Console>
        </Appenders>
        <Loggers>
            <!-- avoid duplicated logs with additivity=false -->
            <Logger name="academy.devdojo" level="info" additivity="false">
                <AppenderRef ref="LogToConsole"/>
            </Logger>
            <Root level="error">
                <AppenderRef ref="LogToConsole"/>
            </Root>
        </Loggers>
    </Configuration>


---> Podemos também realizar a injeção de dependências pelo construtor!
Basta gerar o construtor que alimente a dependência desejada, assim
o próprio container Springboot irá gerenciar e injetar a dependência,
desde que a Classe ainda esteja sendo trackeada pelo Spring sendo um Bean!

- Podemos gerar o construtor na unha e ele faz a injeção, ou também
podemos utilizar as anotações do Lombok para gerar o construtor automaticamente
e assim o Spring irá também injetar as dependências corretamente:


- @AllArgsConstructor: Cria um construtor que injeta em todos os campos;

    @AllArgsConstructor
    public class AnimeController {
        private DateUtil dateUtil;
        ...
    }

- @RequiredArgsConstructor: Cria um construtor que injeta apenas em campos finais.

    @RequiredArgsConstructor
    public class AnimeController {
        private final DateUtil dateUtil;
        ...
    }

---> Tôda aplicação Spring utiliza as anotações básicas no ApplicationStarter sendo elas:
Essas anotações formam a base para criar um app Spring, aonde uma auto configura o básico
para rodar, a outra possibilita o Spring escanear os códigos e trackear os beans e a outra
é utilizada para configurações de segurança (@Configuration) no Filter Chain;

    @EnableAutoConfiguration
    @ComponentScan
    @Configuration
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

- Então o Spring cria uma anotação que une todas essas em apenas uma sendo ela:

    @SpringBootApplication
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 05 - Hot Swap com Spring Boot Devtools]:
Dependências do SpringBoot para tempo de desenvolvimento, otimizando tarefas
como re-bootar automaticamente o projeto ao alterar alguma classe por exemplo...
esse recurso possibilita subir a aplicação mais rápidamente.

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
    </dependency>

- Só de add essa depedência no POM ja habilita o HotSwap que faz a aplicação
executar mais rápido e re-carrega a aplicação toda vez que buildar.

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 06 - Gerando projeto com start.spring.io]:
https://start.spring.io/
- Ao invés de utilizar o schema gerado, eu deixei o meu projeto equivalente a ele!

- Add application.properties em resources;
- Ajusta POM para algumas dependẽncias só serem consideradas em tempo de desenvolvimento;

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 07 - Método GET parte 1]:

- Primeiro devemos alterar o nome do contexto no controller para o plural:

    @RequestMapping("anime") // <- AQUI vamos deixar "animes"
    @RequiredArgsConstructor
    public class AnimeController {
    ...
    }

- Também iremos remover o path do @GetMapping(path="list") pois agora ao executar GET no / do animes
ele considera esse método!

    * Antes:
    @GetMapping(path="list")
    public List<Anime> list() {
      return List.of(new Anime("DBZ"),
                     new Anime("Berserk"));
    }

    * Depois:
    @GetMapping
    public List<Anime> list() {
      return List.of(new Anime("DBZ"),
                     new Anime("Berserk"));
    }

- Também iremos retirar as regras de negócio do Controller e delegar para Service:

- Para isso primeiro vamos remover todos getters e setters, e também o construtor
da classe de dominio Anime, e adicionar a anotação @Data e @AllArgsConstructor
para gerar:
    - getters and setters;
    - equals e hashcode;
    - toString;

    @Data
    @AllArgsConstructor
    public class Anime {
        private Long id;
        private String name;
    }


---> Devemos anotar o serviço com @Service e devemos injetar a dependência do Serviço
tornando esse atributo também final para a anotação do Lombok @RequiredArgsConstructor
funcionar corretamente para esse fild também!

    @RequiredArgsConstructor // -> cria o construtor apenas para field final
    public class AnimeController {
        private final DateUtil dateUtil;
        private final AnimeService animeService; // deixamos ele como "final" também

        @GetMapping
        public List<Anime> list() {
            ...
            return animeService.listAll();
        }
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 08 - Método GET parte 2]:

- Adicionando resposta HTTP no controller com ResponseEntity<>();

    * Antes:
    @GetMapping
    public List<Anime> list() {
        ...
        return animeService.listAll();
    }

    * Depois:
    @GetMapping
    public ResponseEntity<List<Anime>> list() {
        ...
        return new ResponseEntity<>(animeService.listAll(), HttpStatus.OK);
        // return ResponseEntity.ok(animeService.listAll());
    }


---> Problemas quando temos mais de um GetMapping sem contexto:
Neste cenário o Spring não saberá qual método chamar quando rolar GET em animes:

    @GetMapping
    public ResponseEntity<List<Anime>> list() {
       ...
    }
    @GetMapping
    public ResponseEntity<Anime> findById() {
        ...
    }

- Solução: Adicionar um contexto de path variable para algum dos GET:

    @GetMapping(path="/{id}")
    public ResponseEntity<Anime> findById(@PathVariable long id) {
        ...
    }

---> Criaremos o método findById no serviço, e em casos de notFound
devemos retornar response HTTP correspondente com Throws new Exception:

     public Anime findById(long id) {
        return animeList.stream()
                .filter(anime -> anime.getId() == id)
                .findFirst()
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST,
                                                               "Anime Not Found"));
    }

---> Devemos configurar o Spring para não enviar tôdo o StackTrace em casos de Exceptions
para o Frontend:

- Primeiro devemos criar o arquivo de conf em resources:
Alterar o application.properties para application.yml
e setar:

    server:
      error:
        include-stacktrace: never // ou on_trace_param ai basta incluir ?trace=true na URL
                                  // http://localhost:8080/animes/12?trace=true
