[Spring Boot Essentials 2 - Introdução ao curso.]:

- Explicações sobre o curso, 2 pois ja teve o 1, porém esse esta mais atualizado!
- Novos conteúdos (Exemplo: Criar uma imagem da aplicação e subir no docker);
- Overview geral sobre o curso

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 01 - O que é Spring Boot]:

- Criado pela galera da privaton, o intuito é criar app standalone (sem dependências, e iniciar rápidamente);
- O Framework toma conta de todas as configurações por nós, poucas configurações são delegadas a nós;
- Já vem com alguns servlet containers imbutidos (Tomcat, jetty, Undertow);
- O Springboot gerencia as dependências através dos Starters, possuindo uma integração forte com o ecossistema Spring;
- Ecossistema Spring: SpringBoot, Spring Framework, Spring Data, Spring Cloud, Spring Cloud Data Flow, Spring Security, dentre outros;
- Facilmente integrados com o SpringBoot (Basta incluir a dependencia no Maven ou Gradle) e realizar as chamadas;
- Um dos mais utilizados no mercado de trabalho, logo, temos bastante documentações e forums de discussões na web;
- O curso cobre o essencial para iniciar no mundo Spring, cobrindo pelomenos 70% das necessidades;

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 02 - Criando projeto na pedreiragem pt 01]:

- Sem utilizar o starter.io do Spring;
- Inicialmente o projeto inicia sem nada de frameworks (Maven e etc) apenas Java puro na versão 11;
- Add framework (Maven) criando assim o arquivo xml POM e a arvore de diretórios no src;
- Para o Spring gerenciar as dependências, devemos adicionar no pom:
Obs: Para funcionar, o maven deve estar configurado corretamente no projeto!

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
    </parent>

- Após adicionado o parent, podemos adicionar as dependências:

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>

- Para verificar todas as dependências do projeto ir em:
    Botão direito na raiz do projeto > Open Module Settings (f4) > Libraries

- Obs: Adicionamos primeiro o parent para que as dependências logo abaixo herdem as versões corretas do parent!

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 03 - Criando projeto na pedreiragem pt 02]:
Dando start na aplicação Spring WEB!

    package academy.devdojo.springboot2.start;

    import org.springframework.boot.SpringApplication;

    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

Dessa forma não funciona pois não utilizamos as anotações para tornar um Bean Spring!

- Solução 01 - Mais genérica: Utilizar a annotation @EnableAutoConfiguration

    package academy.devdojo.springboot2.start;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.EnableAutoConfiguration;

    @EnableAutoConfiguration
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

Obs: Assim a aplicação inicia em 3.838 seconds, com o Quarkus podemos otimizar e reduzir drasticamente!

---> Testando criando o primeiro Endpoint: package controller!
Utilizaremos a annotation @RestController do SpringMVC para tornar AnimeController
um Bean Spring especializado em API REST (Retornos Strings Json): CTRL + Click na annotation:
- Assinatura da annotation @RestController:

    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Controller
    @ResponseBody
    public @interface RestController {
        @AliasFor(
            annotation = Controller.class
        )
        String value() default "";
    }

- A diferença entre as anotações @RestController e @Controller é que a Rest adiciona um
@ResponseBody que indica que o retorno é uma String ou seja o Objeto Json da resposta Rest!
Diferente do @Controller que é mais genérico e não especializado em respostas Json REST

- Assinatura da annotation @Controller:

    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Component
    public @interface Controller {
        @AliasFor(
            annotation = Component.class
        )
        String value() default "";
    }

---> Caso de problemas ao utilizar classes da API JAVA mais moderna, ou aumentar o language level,
ou adicionar a dependência POM:

     <properties>
        <java.version>11</java.version>
     </properties>


---> Endpoint sem contexto: Quando não anotamos em nível de classe qual será o contexto do Endpoint:
- Obs: @RequestMapping(method = RequestMethod.GET, path = "list") está defasado/obsoleto!
- Novo jeito: @GetMapping(path="list")

    // sem Contexto:
    @RestController
    public class AnimeController {

        // Sem contexto:
        //localhost:8080/list
        @RequestMapping(method = RequestMethod.GET, path = "list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Endpoint COM contexto: Quando anotamos em nível de classe:
- Add @RequestMapping("contexto") a nível de classe:

    // COM Contexto anime:
    @RestController()
    @RequestMapping("anime") // <- ADD AQUI
    public class AnimeController {

        // COM contexto:
        //localhost:8080/anime/list
        @RequestMapping(method = RequestMethod.GET, path = "list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Utilizando o jeito novo: Substituindo @RequestMapping a nível de método para @GetMapping;

    // COM Contexto anime:
    @RestController()
    @RequestMapping("anime")
    public class AnimeController {

        // COM contexto:
        //localhost:8080/anime/list
        // Defasado/obsoleto:
    //    @RequestMapping(method = RequestMethod.GET, path = "list")
        // Novo jeito elegante:
        @GetMapping(path="list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Primeiro erro tentando acessar o Endpoint:

    Whitelabel Error Page
    This application has no explicit mapping for /error, so you are seeing this as a fallback.

    Tue May 30 14:02:32 BRT 2023
    There was an unexpected error (type=Not Found, status=404).

- Isso ocorre pois o Spring deve reconhecer TODAS as classes como um Bean para assim ele gerenciar!
- Ele reconhece isso através da hierarquia de pacotes, e se localiza pela classe "main" ApplicationStart
- Não colocamos ela na raiz, logo ele não encontra!

- Solução 01: Utilizando a anotação no ApplicationStarter.java indicando o path correto:
Utilizando o @ComponentScan(basePackages = "academy.devdojo.springboot2")

    Whitelabel Error Page
    This application has no explicit mapping for /error, so you are seeing this as a fallback.

    Tue May 30 14:13:11 BRT 2023
    There was an unexpected error (type=Internal Server Error, status=500).

- Agora o erro é outro (500): Erro de servidor, problema na serialização.
Isso ocorre geralmente por problemas de não encontrar getters and setters!
Então basta gerar os getters and setters da classe de dominio Anime (Na qual estamos gerando a List)

    [{"name":"DBZ"},{"name":"Berserk"}]

- Isso ocorre pois o Jackson que é a API especializada em Json, utiliza os métodos getters and setters
para pegar os valores e criar a response String JSON!

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 04 - @Component, @Autowired, @SpringBootApplication]:

@Autowried faz a injeção da dependência: Porém desse jeito não é recomendável por questões de segurança!
O Ideal é injetar a dependência pelos setters ou pelo construtor!
- A dependência injetada com @Autowired deve ser um Bean Spring trackeado!!
- Então devemos annotar na classe DateUtil com @Component ou Outras anotações especializadas;

    @Component
    public class DateUtil {
        ...
    }

    public class AnimeController {
        @Autowired
        private DateUtil dateUtil;
        ...
    }

- Obs: O Spring só está conseguindo trackear a classe DateUtil pois estamos escaneando tudo
apartir da raiz do projeto no ApplicationStarter.java com o
@ComponentScan(basePackages = "academy.devdojo.springboot2");
E como a classe está dentro do pacote util que está sendo trackeado, podemos realizar chamadas!

---> Movendo a classe ApplicationStarter para a raiz do projeto, assim não precisamos mais
forçar o scanner com o @ComponentScan(basePackages = "academy.devdojo.springboot2");

- Movendo para a raiz do src do projeto, não precisamos mais indicar o path no @ComponentScan()
pois ele assume como padrão o diretório em que se encontra a classe ApplicationStarter

    @EnableAutoConfiguration
    @ComponentScan
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }


---> Adicionando o Lombok no projeto para utilizar o Log4J2:
- Podemos tambem adicionar a Extensão do Lombok no projeto!

- Obs: Não indicamos a versão pois o Spring irá gerenciar isso para nós!
- Devemos habilitar na IDE o Annotation Processing;
- E se não adicionar o arquivo log4j2.xml em resources, a saída do log será apenas o valor
passado no log.info() e etc.. se quiser mais informações devemos adicionar o arquivo de
configurações log4j2.yml!! mais informações no repositório de estudos Java avançado
MaratonaJava-DevDojo no módulo JDBC (T_jdbc) aula258!
Histórico do commit com maiores detalhes:
https://github.com/WelBert-dev/MaratonaJava-DevDojo/commit/9e06ebafdac1e45420c4d6af3329041386013e80

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>


- EXEMPLO do arquivo log4j2.xml em resources:

    <?xml version="1.0" encoding="UTF-8"?>
    <Configuration status="INFO">
        <Appenders>
            <Console name="LogToConsole" target="SYSTEM_OUT">
                <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
            </Console>
        </Appenders>
        <Loggers>
            <!-- avoid duplicated logs with additivity=false -->
            <Logger name="academy.devdojo" level="info" additivity="false">
                <AppenderRef ref="LogToConsole"/>
            </Logger>
            <Root level="error">
                <AppenderRef ref="LogToConsole"/>
            </Root>
        </Loggers>
    </Configuration>


---> Podemos também realizar a injeção de dependências pelo construtor!
Basta gerar o construtor que alimente a dependência desejada, assim
o próprio container Springboot irá gerenciar e injetar a dependência,
desde que a Classe ainda esteja sendo trackeada pelo Spring sendo um Bean!

- Podemos gerar o construtor na unha e ele faz a injeção, ou também
podemos utilizar as anotações do Lombok para gerar o construtor automaticamente
e assim o Spring irá também injetar as dependências corretamente:


- @AllArgsConstructor: Cria um construtor que injeta em todos os campos;

    @AllArgsConstructor
    public class AnimeController {
        private DateUtil dateUtil;
        ...
    }

- @RequiredArgsConstructor: Cria um construtor que injeta apenas em campos finais.

    @RequiredArgsConstructor
    public class AnimeController {
        private final DateUtil dateUtil;
        ...
    }

---> Tôda aplicação Spring utiliza as anotações básicas no ApplicationStarter sendo elas:
Essas anotações formam a base para criar um app Spring, aonde uma auto configura o básico
para rodar, a outra possibilita o Spring escanear os códigos e trackear os beans e a outra
é utilizada para configurações de segurança (@Configuration) no Filter Chain;

    @EnableAutoConfiguration
    @ComponentScan
    @Configuration
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

- Então o Spring cria uma anotação que une todas essas em apenas uma sendo ela:

    @SpringBootApplication
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 05 - Hot Swap com Spring Boot Devtools]:
Dependências do SpringBoot para tempo de desenvolvimento, otimizando tarefas
como re-bootar automaticamente o projeto ao alterar alguma classe por exemplo...
esse recurso possibilita subir a aplicação mais rápidamente.

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
    </dependency>

- Só de add essa depedência no POM ja habilita o HotSwap que faz a aplicação
executar mais rápido e re-carrega a aplicação toda vez que buildar.

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 06 - Gerando projeto com start.spring.io]:
https://start.spring.io/
- Ao invés de utilizar o schema gerado, eu deixei o meu projeto equivalente a ele!

- Add application.properties em resources;
- Ajusta POM para algumas dependẽncias só serem consideradas em tempo de desenvolvimento;

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 07 - Método GET parte 1]:

- Primeiro devemos alterar o nome do contexto no controller para o plural:

    @RequestMapping("anime") // <- AQUI vamos deixar "animes"
    @RequiredArgsConstructor
    public class AnimeController {
    ...
    }

- Também iremos remover o path do @GetMapping(path="list") pois agora ao executar GET no / do animes
ele considera esse método!

    * Antes:
    @GetMapping(path="list")
    public List<Anime> list() {
      return List.of(new Anime("DBZ"),
                     new Anime("Berserk"));
    }

    * Depois:
    @GetMapping
    public List<Anime> list() {
      return List.of(new Anime("DBZ"),
                     new Anime("Berserk"));
    }

- Também iremos retirar as regras de negócio do Controller e delegar para Service:

- Para isso primeiro vamos remover todos getters e setters, e também o construtor
da classe de dominio Anime, e adicionar a anotação @Data e @AllArgsConstructor
para gerar:
    - getters and setters;
    - equals e hashcode;
    - toString;

    @Data
    @AllArgsConstructor
    public class Anime {
        private Long id;
        private String name;
    }


---> Devemos anotar o serviço com @Service e devemos injetar a dependência do Serviço
tornando esse atributo também final para a anotação do Lombok @RequiredArgsConstructor
funcionar corretamente para esse fild também!

    @RequiredArgsConstructor // -> cria o construtor apenas para field final
    public class AnimeController {
        private final DateUtil dateUtil;
        private final AnimeService animeService; // deixamos ele como "final" também

        @GetMapping
        public List<Anime> list() {
            ...
            return animeService.listAll();
        }
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 08 - Método GET parte 2]:

- Adicionando resposta HTTP no controller com ResponseEntity<>();

    * Antes:
    @GetMapping
    public List<Anime> list() {
        ...
        return animeService.listAll();
    }

    * Depois:
    @GetMapping
    public ResponseEntity<List<Anime>> list() {
        ...
        return new ResponseEntity<>(animeService.listAll(), HttpStatus.OK);
        // return ResponseEntity.ok(animeService.listAll());
    }


---> Problemas quando temos mais de um GetMapping sem contexto:
Neste cenário o Spring não saberá qual método chamar quando rolar GET em animes:

    @GetMapping
    public ResponseEntity<List<Anime>> list() {
       ...
    }
    @GetMapping
    public ResponseEntity<Anime> findById() {
        ...
    }

- Solução: Adicionar um contexto de path variable para algum dos GET:

    @GetMapping(path="/{id}")
    public ResponseEntity<Anime> findById(@PathVariable long id) {
        ...
    }

---> Criaremos o método findById no serviço, e em casos de notFound
devemos retornar response HTTP correspondente com Throws new Exception:

     public Anime findById(long id) {
        return animeList.stream()
                .filter(anime -> anime.getId() == id)
                .findFirst()
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST,
                                                               "Anime Not Found"));
    }

---> Devemos configurar o Spring para não enviar tôdo o StackTrace em casos de Exceptions
para o Frontend:

- Primeiro devemos criar o arquivo de conf em resources:
Alterar o application.properties para application.yml
e setar:

    server:
      error:
        include-stacktrace: never // ou on_trace_param ai basta incluir ?trace=true na URL
                                  // http://localhost:8080/animes/12?trace=true

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 09 - Método POST]:
A depender do padrão adotado temos várias possibilidades de respostas para esse tipo,
por exemplo: quando o método retorna algo ou não.

- Podemos retornar um ID e retorna protocolo HTTP Status 201 CREATED;
- Podemos retornar apenas 201 CREATED e sem Body na response;
- Podemos retornar o Objeto criado inteiro ou um DTO que o represente;

---> Quando mapeamos que estamos recebendo um Json no Body da request POST,
podemos utilizar a anoatação @ e o Jackson irá mapear e converter o JSON
do body para a Entidade correspondente no Java:

    @PostMapping
    public ResponseEntity<Anime> save(@RequestBody Anime anime) {
        ...
    }

- Obs: Para que isso seja possivel as propriedades/atributos do body JSON deve ser
EXATAMENTE igual a entidade correspondente do Java! caso contrario, para os
campos que são diferentes o Jackson irá ignorar e deixar NULL!

- SOLUÇÃO para quando o JSON do body for diferente da Entidade no java:
Utilizar a anotação @JsonProperty("nome-que-vem-no-body-json")

    @Data
    @AllArgsConstructor
    public class Anime {
        private Long id;
        @JsonProperty("name") // aqui mapeamos como vem no Body JSON
        private String nameCharacter;
    }

---> Para retornar o protocolo 201 CREATED sem uma URI devemos fazer com new:

    @PostMapping
    public ResponseEntity<Anime> save(@RequestBody Anime anime) {
        ...
        return new ResponseEntity<>(animeService.save(anime), HttpStatus.CREATED);
    }

- Podemos também utilizar a anotação a nível de método:

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ResponseEntity<Anime> save(@RequestBody Anime anime) {
        ...
        return new ResponseEntity<>(animeService.save(anime), HttpStatus.CREATED);
    }

- Instalamos o POSTMAN para testar esse Endpoint! Tudo certo ;D

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 10 - Método DELETE]: NÃO FUNCIONAL AINDA LER DETALHES:
- Referência normalizada para implementações dos metodos HTTP: RFC7231
- Existem métodos Safes que são metodos que não alteram drasticamente o estado
da aplicação, esses métodas são liberados sem precisar configurar.
- DIFERENTE acontece com DELETE pois é non-safe, emtão devemos configurar
manualmente liberando esse método!! além dele o PUT também!!

- Resposta quando não tratado:

    HttpRequestMethodNotSupportedException: Request method 'DELETE' not supported

- Tabela dos métodos e seus níveis de safedade:

    +---------+------+------------+---------------+
    | Method  | Safe | Idempotent | Reference     |
    +---------+------+------------+---------------+
    | CONNECT | no   | no         | Section 4.3.6 |
    | DELETE  | no   | yes        | Section 4.3.5 |
    | GET     | yes  | yes        | Section 4.3.1 |
    | HEAD    | yes  | yes        | Section 4.3.2 |
    | OPTIONS | yes  | yes        | Section 4.3.7 |
    | POST    | no   | no         | Section 4.3.3 |
    | PUT     | no   | yes        | Section 4.3.4 |
    | TRACE   | yes  | yes        | Section 4.3.8 |
    +---------+------+------------+---------------+

- Pesquisar mais sobre Idempotent pois a depender do tipo de method HTTP em request
e se ele pode alterar o estado da aplicação, podemos ter problemas na request!

Deletando de acordo com o ID e podemos também seguir alguma convensão de retorno HTTP:

- Podemos retornar um ID e retorna protocolo HTTP Status 204 NoContent;
- Podemos retornar apenas 204 NoContent e sem Body na response;
- Podemos o Objeto deletado inteiro ou um DTO que o represente;

- OBS: ATÉ AQUI NÃO CONFIGURAMOS O MÉTODO DELETE NA API ENTÃO NÃO ESTÁ FUNCIONAAL AINDA!

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 11 - Método PUT]:
Idempotente ou seja, toda evz que executado a resposta deve ser a mesma!

- Podemos retornar um ID e retorna protocolo HTTP Status 204 NoContent;
- Podemos retornar apenas 204 NoContent e sem Body na response;
- Podemos o Objeto replaced inteiro ou um DTO que o represente;

    @PutMapping
    public ResponseEntity<Void> replace(@RequestBody Anime anime) {
        animeService.replace(anime);

        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 12 - Instalando Docker e executando container MySQL]:
- Copiei o docker-compose do projeto Maratona-Java;

1o - Criar o arquivo docker-compose.yml na raiz do projeto (configurações do container);
2o - Rodar o container: docker-compose up (obs: . deve estar no diretório do arquivo anterior .yml);
        - Caso não exista a imagem ainda, ele faz o download;

3o - Verificando se o container esta running: docker ps;
4o - Verificando TODOS containers disponíveis, até mesmo os que não estão running: docker ps -a;
5o - Removendo containers pelo docker-compose: docker-compose down;
6o - Mesmo removendo containers os volumes mapeados ainda ficam, para verificar: docker volume ls;

---> Executando comandos no container:

# Entra no container pelo shell corrente:
docker exec -it container_id bash

# Conecta com o mysql:
mysql -uroot -p

---> Adicionando dependências no projeto: pom.xml (Mysql v8.0.33)

1o - https://mvnrepository.com/artifact/mysql/mysql-connector-java > Mysql v8.0.33 Connector Java;

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>

2o - Reload Maven para baixar a dependencia adicionada acima (CTRL + SHIFT + O);

3o - Verificando se as dependências foram baixadas com sucesso: Ir na raiz > `External Libraries`;

4o - Após adicionar as dependências do mysql ao projeto, iremos criar a lógica de connection.

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 13 - Spring Data JPA pt 01]:

- Instala o JPA e o MysqlConnector (Já fiz na aula anterior sobre o mysql connector);

Mapeando automaticamente e atualizando em tempo real os schemas das tabelas
com o Spring Data JPA.

- Database: db_anime_sprinboot2

---> Adicionando dependências no projeto: pom.xml (Spring Data JPA v2.4.0)

     <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

---> Atualiza o arquivo /resources/application.yml:

    spring:
      datasource:
        url: jdbc:mysql://localhost:3306/db_anime_sprinboot2?useSSL=false&createDatabaseIsNotExists=true&allowPublicKeyRetrieval=true
        username: root
        password: root
      jpa:
        hibernate:
          ddl-auto: update

---> Transfromando o modelo de domínio Java em Entidade para mapear no banco:

- Modifica o modelo de dominio /domain/Anime.java:
    - Add a annotation em nível de classe: @Entity(name = "tbl_anime")
    - Add a annotation em nível de atributo: @Id e @GeneratedValue(strategy = GenerationType.IDENTITY)

    @Data
    @AllArgsConstructor
    @Entity(name = "tbl_anime")
    public class Anime {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;
    }

    - Resultado após executado a aplicação:
    Será criado uma tabela `tbl_anime` com o seguinte desc:

    +-------+--------------+------+-----+---------+----------------+
    | Field | Type         | Null | Key | Default | Extra          |
    +-------+--------------+------+-----+---------+----------------+
    | id    | bigint       | NO   | PRI | NULL    | auto_increment |
    | name  | varchar(255) | YES  |     | NULL    |                |
    +-------+--------------+------+-----+---------+----------------+

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 14 - Spring Data JPA pt 02]:
- Criando o AnimeRepository classe que faz as querys relacionadas a tabela Anime:
- Aonde "Long" é o tipo da primary key
- Não precisamos definir metodos pois ja estamos herdando os default (insert, update, find..)

    public interface AnimeRepository extends JpaRepository<Anime, Long> {
    }

---> Devemos atualizar todos os metodos anteriores que utilizavam DB in Memory (List);

---> Devemos criar as classes DTO correspondente para cada method http do request;

    @Data
    public class AnimePostRequestBodyDTO {
        private String name;
    }

    @Data
    public class AnimePutRequestBodyDTO {
        private Long id;
        private String name;
    }

---> Atualizar a Classe AnimeService para agora utilizar os métodos herdados do
extends JpaRepository<Anime, Long> e mapear os campos do DTO para a Entidade Java.

    @Service
    @RequiredArgsConstructor
    public class AnimeService {
        private final AnimeRepository animeRepository;
        ...
    }

    public Anime save(AnimePostRequestBodyDTO animeDTO) {
        // Mapeia o DTO para a Entidade, e ja retorna o registro com o ID

        return this.animeRepository.save(Anime.builder()
                .name(animeDTO.getName()).build());
    }

---> Atualizar a Entidade de dominio Anime para não dar problemas no Jackson:

    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor // <-- Tava dandoi erro de construtor padrão, porisso adicionei essa annotation
    @Entity(name = "tbl_anime")
    public class Anime {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;
    }

---> Pronto, agora a API esta acessando o Banco de dados Mysql nas consultas,
além de manter os schemas e registros refletidos na aplicação e no banco.

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 15 - Framework de Mapeamento MapStruct]:
- Facilitando o mapeamento de DTO's para Entidades concretas;
- Vantagem: Ele faz alguns tratamentos e validações por nós (null's e etc);
- Obs: Os campos do DTO devem ser compatíveis com a Entidade model, ou devemos
especificar com a anotação @Mapping(source = "nameDto", target = "nameEntity")
indicando qual é o campo mapeado de um para outro;

---> Adicionando dependências no projeto: pom.xml (MapStruct v1.5.5.Final):

    <properties>
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version>
    </properties>

    <dependency>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
        <version>${org.mapstruct.version}</version>
    </dependency>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>11</source> <!-- depending on your project -->
                    <target>11</target> <!-- depending on your project -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <!-- other annotation processors -->
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>

---> Criaremos um pacote separado para definição de mapeamento `mapper`:

    @Mapper(componentModel = "spring") // possibilita fazer dependency injection
    public abstract class AnimeMapper {
        public static final AnimeMapper INSTANCE = Mappers.getMapper(AnimeMapper.class);

        public abstract Anime toAnime(AnimePostRequestBodyDTO animePostRequestBodyDTO);
        public abstract Anime toAnime(AnimePutRequestBodyDTO putRequestBodyDTO);
    }

---> Realizando as chamadas no mapper ao invés de mapear manualmente:

    public Anime save(AnimePostRequestBodyDTO animePostDTO) {
        return this.animeRepository.save(AnimeMapper.INSTANCE.toAnime(animePostDTO));
    }

---> ATENÇÃO: Por adicionar as configurações de annotation proccessors do Mapper no POM
devemos também adicionar PARA TODAS as dependências que utilizam esse proccessor!!

- Neste caso devemos habilitar as annotation processor do Lombok:

    <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.8.1</version>
                    <configuration>
                        <source>11</source> <!-- depending on your project -->
                        <target>11</target> <!-- depending on your project -->
                        <annotationProcessorPaths>
                            <path>
                                <groupId>org.mapstruct</groupId>
                                <artifactId>mapstruct-processor</artifactId>
                                <version>${org.mapstruct.version}</version>
                            </path>
                            <!-- other annotation processors -->
                            <path>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok</artifactId>
                                <version>${lombok.version}</version>
                            </path>
                        </annotationProcessorPaths>
                    </configuration>
                </plugin>
            </plugins>
        </build>

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 16 - Request Params]: Parâmetros na URL ao invés do body da request

---> Primeiro iremos definir o contrato List<Anime> findByName(String name) na
interface AnimeRepository, apenas definir pois o próprio JPA irá implementar para nós!

    public interface AnimeRepository extends JpaRepository<Anime, Long> {
        List<Anime> findByName(String name);
    }

- O findByName deve corresponder com o atributo em questão da Entidade model!
- Obs: Esse find gerado pelo JPA não é com LIKE, ou seja, o valor deve ser 100%
equals (name == name);

- Para visualizar a Query gerada pelo JPA basta flaggar com `show-sql: true`
o application.yml:

    server:
      error:
        include-stacktrace: on_trace_param

    spring:
      datasource:
        url: jdbc:mysql://localhost:3306/db_anime_sprinboot2?useSSL=false&createDatabaseIsNotExists=true&allowPublicKeyRetrieval=true
        username: root
        password: root
      jpa:
        hibernate:
          ddl-auto: update
        show-sql: true // <- AQUI!!

---> Depois devemos espelhar o método na classe de Serviço:

    public List<Anime> findByName(String name) {
        return this.animeRepository.findByName(name);
    }

---> Depois iremos utilizar o serviço no Controlador:
- A anotação @RequestParam é bem parecida com a @PathVariable mas o indicado é
utilizar a @PathVariable quando não vamos passar vários params, se for passar
muitos o indicado é utilizar a RequestParam!

- A anotação @PathVariable o parâmetro é passado "seco" SEM o atributo=valor:

    @GetMapping(path = "/{id}")
    public ResponseEntity<Anime> findById(@PathVariable long id) {
       return ResponseEntity.ok(animeService.findByIdOrThrowBadRequestException(id));
    }

    - URL: http://localhost:8080/animes/2


- Já a anotação @RequestParam o parâmetro é COMPOSTO por atributo=valor:

    @GetMapping(path = "/find")
    public ResponseEntity<List<Anime>> findByName(@RequestParam String name) {
        return ResponseEntity.ok(animeService.findByName(name));
    }

    - URL: http://localhost:8080/animes/find?name=Naruto MAPPER UPDATER 12

- Assim podemos empilhar vários parâmetros da seguinte forma:

    @GetMapping(path = "/find")
    public ResponseEntity<List<Anime>> findByName(@RequestParam String name, @RequestParam String id) {
        return ResponseEntity.ok(animeService.findByName(name));
    }

    - URL: http://localhost:8080/animes/find?name=Naruto MAPPER UPDATER 12&id=12


---> Argumentos do @RequestParam:

- @RequestParam(defaultValue = ""): Valor padrão;
- @RequestParam(required = false): Obrigatório? se for, return BAD REQUEST

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 17 - Exceções Customizadas]: Criando Exceptions nas Response HTTP
- O Tratamento de Exceptions vai depender do padrão adotado pelo projeto!
- Não existe um caminho apenas, as melhores práticas é adotar um padrão para o tôdo.
- Neste contexto iremos criar uma Exception personalizada para a Response HTTP BAD REQUEST
- BadRequestException extends RuntimeException; Passando para o `super` a message do construtor;
- Para não implementar na unha o Throw, utilizaremos @ResponseStatus(HttpStatus.BAD_REQUEST)
a nível de classe na Exception customizada!
- Assim não precisamos mais utilizar o genérico em Service:

     new ResponseStatusException(HttpStatus.BAD_REQUEST,"Anime Not Found");

- Agora com a Exception customizada, a chamada/resposta será menos verboso:

    new BadRequestException("Anime Not Found");

- Vantagens: Redução de Boilerplates e possibilidades de tratamentos personalizados!

---> Primeiro iremos criar o diretório exceptions/httpRequest para centralizar essas
customizações!

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public class BadRequestException extends RuntimeException {
        public BadRequestException(String message) {
            super(message);
        }
    }

---> Depois basta substituir as chamadas no Service:

    [ANTES DE UTILIZAR A EXCEPTION CUSTOMIZADA]:

    public Anime findByIdOrThrowBadRequestException(long id) {
        return this.animeRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, // <- AQUI
                                                                "Anime Not Found"));
    }

    [DEPOIS UTILIZANDO A EXCEPTION CUSTOMIZADA]:

    public Anime findByIdOrThrowBadRequestException(long id) {
        return this.animeRepository.findById(id)
                .orElseThrow(() -> new BadRequestException("Anime Not Found")); // <- BEM MELHOR
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 18 - Handler Global]: Personalizando campos do retorno
Response HTTP Exception, ou seja, configurando manualmente o método que é
executado quando lança alguma Exception relacionada ao Controller, por exemplo
HTTP BAD REQUEST que criamos anteriormente!

---> [ANTES] de personalizar, a resposta default do STATUS 400 é algo parecido com:

    {
        "timestamp": "2023-06-07T19:11:22.004+00:00",
        "status": 400,
        "error": "Bad Request",
        "message": "Anime Not Found",
        "path": "/animes/50"
    }

---> Primeiro iremos definir a classe que vai encapsular os campos personalizados
deste retorno Response HTTP de acordo com o tipo de status code (400, 404 e etc)
ou também podemos definir um genérico para todos, ou para um grupo seleto de status
code em casos de campos similares ou iguais. (Utilizar o conceito de herança).

- Iremos definir a classe no mesmo pacote do BadRequestException personalziado anterior.
- Boas práticas de nomeclatura: TipoExceptionHTTPDetails: BadRequestExceptionDetails

    @Data
    @Builder
    public class BadRequestExceptionDetails {
        private String title;
        private int status;
        private String details;
        private String developerMessage;
        private LocalDateTime timestamp;
        private String camposDoRetornoPersonalizado;
    }

- Após definir devemos indicar para todos os Controllers que desejamos utilizar ela
toda vez que lançar uma Exception do tipo BadRequestException que criamos anteriormente!

---> Devemos criar um pacote centralizado para essas configurações:
handler/exceptions/httpRequest

- A Classe será definida para lidar com qualquer request REST: RestExceptionHandler
- Nesta classe de configuração iremos anotar a nível de classe com @ControllerAdvice
para indicar ao Spring que está classe deve ser considerada no controlador para lidar
com alguns cenários, esses cenários deveram ser "flaggados", ou seja, vamos utilizar
outras anotações em nível de métodos paar indicar quais os cenários ele deve chamar
esses métodos personalizados.
- A Anotação que vamos utilizar para definir o cenário em que o Controller deve chamar
o método definido por nós para tratar as Exceptions do tipo BadRequestException criado
por nós anteriormente, e executar esse método toda vez que lançado ela, é a annotation
@ExceptionHandler(BadRequestException.class):

    @ControllerAdvice
    public class RestExceptionHandler {

        @ExceptionHandler(BadRequestException.class)
        public ResponseEntity<BadRequestExceptionDetails> handlerBadRequestException(BadRequestException bre) {
            return new ResponseEntity<>(
                    BadRequestExceptionDetails.builder()
                            .timestamp(LocalDateTime.now())
                            .status(HttpStatus.BAD_REQUEST.value())
                            .title("Bad Request Exception, Check the documentation!")
                            .details(bre.getMessage())
                            .developerMessage(bre.getClass().getName())
                            .camposDoRetornoPersonalizado("HANDLER PERSONALIZADOOO! ;D").build()
                    , HttpStatus.BAD_REQUEST
            );
        }
    }

---> [RESULTADO] (Toda vez que lançar a exception BadRequestException criadas por
nós anteriormente, será chamado esse método:
- Obs: Fiz a mesma requisição que gerou o Response da seção "[ANTES] " logo a cima /\

    {
        "title": "Bad Request Exception, Check the documentation!",
        "status": 400,
        "details": "Anime Not Found",
        "developerMessage": "academy.devdojo.springboot2.exceptions.httpRequest.BadRequestException",
        "timestamp": "2023-06-07T16:42:45.408296358",
        "camposDoRetornoPersonalizado": "HANDLER PERSONALIZADOOO! ;D"
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 19 - Transações]: Cancelando transações com o banco em
casos de lançar Exceptions, ou seja, em alguns cenários não iremos querer
persistir dados no banco em casos de ocorrer problemas, sem definir essas regras
o padrão é mesmo se lançado, o código continua executando e salvando, por exemplo
um registro no banco, coisa que não deveria ocorrer em casos de lançado Exceptions

- Para resolver isso primeiro o banco deve possuir suporte para transações, podemos
verificar esse recurso com o SQL: `show table status` e verificar se na coluna
"Engine" temos o valor "InnoDB"; MYSQL POSSUÍ SUPORTE! ;D

- Para indicar ao Spring que desejamos parar qualquer transação com o banco em casos
de lançar Exception, utilizamos a annotation @Transactional no método que lança a
Exception em questão! por padrão, sem utilizar nada no argumento da annotation o
Spring só vai considerar essa flag em Exceptions do tipo Unchecked ou seja, Runtime
Exceptions (Exceções lançadas em tempo de execução, as quais não samos como desenvolvedores
obrigados a trata-las com blocos try-catch);

- Para considerar esse tipo de Exception (Sem ser Runtime) as Checked devemos utilizar
no argumento indicando para qual Exception Checked queremos considerar também!

- OBS: A ANNOTATION É DO SPRING FRAMEWORK, NÃO DO JAVAX (POIS EXISTE UMA IGUAL NELE)
CUIDADO NA HORA DE IMPORTAR!!!

---> Como exemplo iremos definir essas regras no método save do AnimeService:

    @Transactional
    public Anime save(AnimePostRequestBodyDTO animePostDTO) {
        Anime anime = AnimeMapper.INSTANCE.toAnime(animePostDTO);
        System.out.println(anime);
        return this.animeRepository.save(anime);
    }

---> Para Exceptions Checked (Aquelas que herdam de Exception) no qual devemos
obrigatoriamente trata-las com try-catch ou delegar a responsabilidade para
quem esta chamando com Throws na assinatura, devemos indicar no argumento
essa Exception Checked em questão:

    @Transactional(rollbackFor = BadRequestException.class)
    public Anime save(AnimePostRequestBodyDTO animePostDTO) throws Exception { // <- Checked Exception
        Anime anime = AnimeMapper.INSTANCE.toAnime(animePostDTO);

        if(true)
            throw new Exception("Teste"); // Forçamos o throws para teste

        return this.animeRepository.save(anime);
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 20 - Validação de campos]: Validações padrões com uso
de annotations.

- Campos obrigatórios;
- Campos não null;

---> Adicionando dependências no projeto: pom.xml:

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

- PRIMEIRO Iremos anotar com não null o campo que vem do RequestBody nos DTOs:
'./src/main/java/academy/devdojo/springboot2/requests/anime'

    @Data
    public class AnimePostRequestBodyDTO {
        @NotEmpty(message = "The anime name cannot be empty!") <- AQUI
        private String name;
    }

    @Data
    public class AnimePutRequestBodyDTO {
        @NotNull(message = "The anime ID cannot be NULL!") <- AQUI
        private Long id;
        @NotEmpty(message = "The anime name cannot be empty!") <- AQUI
        private String name;
    }

- DEPOIS devemos flagger os parâmetros que vem do Controllador com @Valid:
Obs: Nas duas chamadas dos DTO's anotados com as validações ditos a cima:
                                                    AQUI
    @PostMapping                                     \/
    public ResponseEntity<Anime> save(@RequestBody @Valid AnimePostRequestBodyDTO animeDTO) {
        System.out.println("\n\n\n\n"+animeDTO);
        return new ResponseEntity<>(animeService.save(animeDTO), HttpStatus.CREATED);
    }
                                                      AQUI
    @PutMapping                                        \/
    public ResponseEntity<Void> replace(@RequestBody @Valid AnimePutRequestBodyDTO animeDTO) {
        animeService.replace(animeDTO);

        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

---> Possibilidades:

- @URL: Tratar URL's (Regex)
- @Min: Tratar campos numéricos;
- @Max: Tratar campos numéricos;

---> CASO as validações detect algo de errado o Spring lança BAD REQUEST Exception, porém
não é o handler tratado por nós que será invocado, temos que ditar essas regras também
próxima aula será essa tarefa, retorno SEM alterar as regras de lançamento da Exception:

---> RESOLUÇÃO do problema de mapeamento do MapperStruct:

        @Mapping(target = "name", source = "animePostRequestBodyDTO.name")
        public abstract Anime toAnime(AnimePostRequestBodyDTO animePostRequestBodyDTO);

- Cenário: Request PUT sem nome e etc para não passar nas validações anteriores:

    {
        "timestamp": "2023-06-12T19:54:55.080+00:00",
        "status": 400,
        "error": "Bad Request",
        "message": "Validation failed for object='animePostRequestBodyDTO'. Error count: 1",
        "errors": [
            {
                "codes": [
                    "NotEmpty.animePostRequestBodyDTO.name",
                    "NotEmpty.name",
                    "NotEmpty.java.lang.String",
                    "NotEmpty"
                ],
                "arguments": [
                    {
                        "codes": [
                            "animePostRequestBodyDTO.name",
                            "name"
                        ],
                        "arguments": null,
                        "defaultMessage": "name",
                        "code": "name"
                    }
                ],
                "defaultMessage": "The anime name cannot be empty!",
                "objectName": "animePostRequestBodyDTO",
                "field": "name",
                "rejectedValue": "",
                "bindingFailure": false,
                "code": "NotEmpty"
            }
        ],
        "path": "/animes"
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 21 - Handler para validação de campos]: Personalizando
os campos retornados na resposta HTTP em casos de lançamento de Exceptions
relacionadas as Annotations do spring-boot-starter-validation
(Mesma lógica sobre a aula 18 - Handler Global)

---> [ANTES] de personalizar, a resposta default em casos de inconcistências na
validação:

- Executando POST com "name" do body Vazio "":

    {
        "timestamp": "2023-06-13T22:06:44.636+00:00",
        "status": 400,
        "error": "Bad Request",
        "message": "Validation failed for object='animePostRequestBodyDTO'. Error count: 1",
        "errors": [
            {
                "codes": [
                    "NotEmpty.animePostRequestBodyDTO.name",
                    "NotEmpty.name",
                    "NotEmpty.java.lang.String",
                    "NotEmpty"
                ],
                "arguments": [
                    {
                        "codes": [
                            "animePostRequestBodyDTO.name",
                            "name"
                        ],
                        "arguments": null,
                        "defaultMessage": "name",
                        "code": "name"
                    }
                ],
                "defaultMessage": "The anime name cannot be empty!",
                "objectName": "animePostRequestBodyDTO",
                "field": "name",
                "rejectedValue": "",
                "bindingFailure": false,
                "code": "NotEmpty"
            }
        ],
        "path": "/animes"
    }


---> Primeiro iremos criar uma SuperClasse que irá encapsular os fields PADRÃO,
ou seja, Uma classe EXCEPTION genérica que será extends por outras relacionadas
/especializadas para adição de fields se necessário: exceptions/ExceptionDetails

    @Data
    @SuperBuilder // necessario pois as subclasses utilizam @Builder, se não anotar não funcionará nelas
    public class ExceptionDetails {
        protected String title;
        protected int status;
        protected String details;
        protected String developerMessage;
        protected LocalDateTime timestamp;
    }

---> Depois devemos alterar a classe do pacote exceptions/httpRequest para extends dele:

- [ANTES] BadRequestExceptionDetails:

    @Data
    @Builder
    public class BadRequestExceptionDetails {
        private String title;
        private int status;
        private String details;
        private String developerMessage;
        private LocalDateTime timestamp;
        private String camposDoRetornoPersonalizado;
    }

- [DEPOIS] BadRequestExceptionDetails:

    @Getter // <- Não precisamos gerar toda a estrutura do @Data (Getter já supri)
    @SuperBuilder <- Precisamos trocar de @Builder para @SuperBuilder aqui TAMBÉM!
    public class BadRequestExceptionDetails extends ExceptionDetails {
        private String camposDoRetornoPersonalizado; // <- Deixa apenas o campo "Especializado" desta classe
    }


---> [CRIANDO A ESPECIALIZADA PARA VALIDATION EXCEPTION DETAILS]: Agora iremos
definir a Especializada para este contexto (Exceptions lançadas pelas Anotações
do spring-boot-starter-validation):

- Criaremos a ValidationExceptionDetails extends ExceptionDetails no pacote
exceptions:

    @Getter
    @SuperBuilder
    public class ValidationExceptionDetails extends ExceptionDetails {
        private final String fields;
        private final String fieldsMessage;
    }

---> [DEPOIS] iremos interceptar as ações do Controller com uso do Handler
que irá tratar a exception, neste caso, retornar os campos definidos em Details
para as chamadas HTTP inválidas para as annotations do spring-boot-starter-validation:

- [PRIMEIRO] passo é identificar qual é a Exception lançada pelas annotations do
validador utilizado (spring-boot-starter-validation), para indicarmos ao Spring
que toda vez que lançado ela, ele deverá utilizar o handler definido por nós:

    - Para saber qual é a Exception lançada, podemos utilizar o parâmetro na URL:
    http://localhost:8080/animes?trace=true

    - OBS: Lembrando que para esse parâmetro funcionar devemos settar a configuração
    no arquivo /resources/application.yml:

        server:
          error:
            include-stacktrace: on_trace_param

    - [RESPONSE] Do JSON:

    {
        "timestamp": "2023-06-13T22:34:46.019+00:00",
        "status": 400,
        "error": "Bad Request",
        "trace": "org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [0] in public org.springframework.http.ResponseEntity<academy.devdojo.springboot2.domain.Anime> academy.devdojo.springboot2.controller.AnimeController.save(academy.devdojo.springboot2.requests.anime.AnimePostRequestBodyDTO): [Field error in object 'animePostRequestBodyDTO' on field 'name': rejected value []; codes [NotEmpty.animePostRequestBodyDTO.name,NotEmpty.name,NotEmpty.java.lang.String,NotEmpty]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [animePostRequestBodyDTO.name,name]; arguments []; default message [name]]; default message [The anime name cannot be empty!]] \n\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:139)\n\tat org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:170)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:893)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:807)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1061)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:961)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.base/java.lang.Thread.run(Thread.java:833)\n",
        "message": "Validation failed for object='animePostRequestBodyDTO'. Error count: 1",
        "errors": [
            {
                "codes": [
                    "NotEmpty.animePostRequestBodyDTO.name",
                    "NotEmpty.name",
                    "NotEmpty.java.lang.String",
                    "NotEmpty"
                ],
                "arguments": [
                    {
                        "codes": [
                            "animePostRequestBodyDTO.name",
                            "name"
                        ],
                        "arguments": null,
                        "defaultMessage": "name",
                        "code": "name"
                    }
                ],
                "defaultMessage": "The anime name cannot be empty!",
                "objectName": "animePostRequestBodyDTO",
                "field": "name",
                "rejectedValue": "",
                "bindingFailure": false,
                "code": "NotEmpty"
            }
        ],
        "path": "/animes"
    }

    - PODEMOS NOTAR A EXCEPTION LANÇADA EM:
        "trace": "org.springframework.web.bind.MethodArgumentNotValidException..."


- [IMPLEMENTAÇÃO do Handler em sí]:

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationExceptionDetails> handleMethodArgumentNotValidException(
            MethodArgumentNotValidException exception) {
        log.info("Fields {}", exception.getBindingResult().getFieldError().getField());

        List<FieldError> fieldErrors = exception.getBindingResult().getFieldErrors();

        String fields_str = fieldErrors.stream().map(FieldError::getField).collect(Collectors.joining(", "));
        String fieldsMessage_str = fieldErrors.stream().map(FieldError::getDefaultMessage).collect(Collectors.joining(", "));

        return new ResponseEntity<>(
                ValidationExceptionDetails.builder()
                        .timestamp(LocalDateTime.now())
                        .status(HttpStatus.BAD_REQUEST.value())
                        .title("Bad Request Exception, Invalid Fields!")
                        .details("Check the field(s) error")
                        .developerMessage(exception.getClass().getName())

                        .fields(fields_str) // Aqui estão os Fields personalizados/especializados
                        .fieldsMessage(fieldsMessage_str).build()
                , HttpStatus.BAD_REQUEST
        );
    }


---> [FINALMENTE RESPONSE JSON PERSONALIZADO]:

    {
        "title": "Bad Request Exception, Invalid Fields!",
        "status": 400,
        "details": "Check the field(s) error",
        "developerMessage": "org.springframework.web.bind.MethodArgumentNotValidException",
        "timestamp": "2023-06-13T19:52:57.881155637",
        "fields": "name",
        "fieldsMessage": "The anime name cannot be empty!"
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 22 - Sobrescrevendo handler do Spring]: O Spring já
trata (Handler) muitas Exceptions por nós, é possível então sobrescrever esses
tratamentos e personaliza-los, como por exemplo o MethodArgumentNotValidException
já existe handler do Spring que faz o tratamento dessa Exception.

- Para saber se uma Exception já possui algum Handler que intercepta e trata
por meio dos Resolvers, podemos verificar no Log. Para lançar Exception e
simular fiz uma requisição com Json INVÀLIDO, pois para esse cenário já existe
Handlers e Resolvers prontos:

    2023-06-14 15:52:21.019  WARN 8292 --- [nio-8080-exec-1]
    .w.s.m.s.DefaultHandlerExceptionResolver :
    Resolved [org.springframework.http.converter.HttpMessageNotReadableException:
    JSON parse error: Unexpected character ('"' (code 34)):
    was expecting a colon to separate field name and value;
    nested exception is com.fasterxml.jackson.core.JsonParseException:
    Unexpected character ('"' (code 34)): was expecting a colon to separate field name and value
     at [Source: (PushbackInputStream); line: 2, column: 14]]

     - Body do Response no POSTMAN: (http://localhost:8080/animes?trace=true)

     {
         "timestamp": "2023-06-14T18:52:21.050+00:00",
         "status": 400,
         "error": "Bad Request",
         "trace": "org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Unexpected character ('\"' (code 34)): was expecting a colon to separate field name and value; nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected character ('\"' (code 34)): was expecting a colon to separate field name and value\n at [Source: (PushbackInputStream); line: 2, column: 14]\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:285)\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.read(AbstractJackson2HttpMessageConverter.java:243)\n\tat org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:205)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:158)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:131)\n\tat org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:170)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:893)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:807)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1061)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:961)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.base/java.lang.Thread.run(Thread.java:833)\nCaused by: com.fasterxml.jackson.core.JsonParseException: Unexpected character ('\"' (code 34)): was expecting a colon to separate field name and value\n at [Source: (PushbackInputStream); line: 2, column: 14]\n\tat com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1851)\n\tat com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:707)\n\tat com.fasterxml.jackson.core.base.ParserMinimalBase._reportUnexpectedChar(ParserMinimalBase.java:632)\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._skipColon2(UTF8StreamJsonParser.java:3138)\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._skipColon(UTF8StreamJsonParser.java:3067)\n\tat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:765)\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:160)\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4526)\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3521)\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:274)\n\t... 51 more\n",
         "message": "JSON parse error: Unexpected character ('\"' (code 34)): was expecting a colon to separate field name and value; nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected character ('\"' (code 34)): was expecting a colon to separate field name and value\n at [Source: (PushbackInputStream); line: 2, column: 14]",
         "path": "/animes"
     }

---> Primeiro passo para sobrescrever esses Handlers do Spring é Extends na classe
RestExceptionHandler extends ResponseEntityExceptionHandler

- Para saber como o Spring faz o tratamento, basta CTRL + Click no ResponseEntityExceptionHandler
e lá temos tratamento para essas Exceptions:

    @ExceptionHandler({
    			HttpRequestMethodNotSupportedException.class,
    			HttpMediaTypeNotSupportedException.class,
    			HttpMediaTypeNotAcceptableException.class,
    			MissingPathVariableException.class,
    			MissingServletRequestParameterException.class,
    			ServletRequestBindingException.class,
    			ConversionNotSupportedException.class,
    			TypeMismatchException.class,
    			HttpMessageNotReadableException.class,
    			HttpMessageNotWritableException.class,
    			MethodArgumentNotValidException.class,   <--- Essa nós fizemos handler na aula anterior
    			MissingServletRequestPartException.class,
    			BindException.class,
    			NoHandlerFoundException.class,
    			AsyncRequestTimeoutException.class
    		})

- Ctrl + F em "MethodArgumentNotValidException":

    ...
    else if (ex instanceof MethodArgumentNotValidException) {
        HttpStatus status = HttpStatus.BAD_REQUEST;
        return handleMethodArgumentNotValid((MethodArgumentNotValidException) ex, headers, status, request);
    }

- Ctrl + Click no retorno: "handleMethodArgumentNotValid((MethodArgumentNotValidException...":

    ...
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {

        return handleExceptionInternal(ex, null, headers, status, request);
    }

- Ctrl + Click no retorno Novamente "handleExceptionInternal(ex...":

    ...
    protected ResponseEntity<Object> handleExceptionInternal(
    			Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatus status, WebRequest request) {

        if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {
            request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);
        }
        return new ResponseEntity<>(body, headers, status);
    }

---> Iremos copiar essa assinatura e Sobrescrever ela em `handler/exceptions/
httpRequest/RestExceptionHandler.java` que agora Extends de `org/springframework/
web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.java`,
adicionando no retorno os campos personalizados definidos na classe Details genérica
da aula anterior em `exceptions/ExceptionDetails.java`:

- Sobrescrevendo o método `protected ResponseEntity<Object> handleExceptionInternal`:
na classe `handler/exceptions/httpRequest/RestExceptionHandler.java` e retornar
o ExceptionDetails genérico definido na aula anterior:

    @Override
    protected ResponseEntity<Object> handleExceptionInternal(
            Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatus status, WebRequest request) {

        ExceptionDetails exceptionDetails = ExceptionDetails.builder()
                .timestamp(LocalDateTime.now())
                .status(status.value())
                .title(ex.getCause().getMessage())
                .details(ex.getMessage())
                .developerMessage(ex.getClass().getName()).build();

        return new ResponseEntity<>(exceptionDetails, headers, status);
    }

- [DUVIDA]: QUANDO o Spring chama esse handle? Não foi explicado no vídeo!
- [DUVIDA TIRADA!!]: Esse método é polimorfico e é chamado para TODAS
as Exceptions lançadas e tratadas nesta classe `ResponseEntityExceptionHandler`
pois a estrutura do retorno para todas é o mesmo, mudando apenas os valores
dos campos, porisso foi extraído um método unico para todas, já que
o código se repetiria em todos os tratamentos, mudando apenas os valores,
então basta parâmetrizar esses campos e passa-los na chamada, agora que
sobrescrevemos, TODAS essas Exceptions tratadas na classe `ResponseEntityExceptionHandler`
VÃO Passar a chamar esse método que definimos, então o retorno será genérico
para todas elas.

- Executando o mesmo cenário do começo da aula que gerou o JSON INVÀLIDO,
porém agora a resposta do Body é diferente pois sobrescrevemos o
`handleExceptionInternal`: (http://localhost:8080/animes?trace=true)

    {
        "title": "Unexpected character ('\"' (code 34)): was expecting a colon to separate field name and value\n at [Source: (PushbackInputStream); line: 2, column: 14]",
        "status": 400,
        "details": "JSON parse error: Unexpected character ('\"' (code 34)): was expecting a colon to separate field name and value; nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected character ('\"' (code 34)): was expecting a colon to separate field name and value\n at [Source: (PushbackInputStream); line: 2, column: 14]",
        "developerMessage": "org.springframework.http.converter.HttpMessageNotReadableException",
        "timestamp": "2023-06-14T17:17:35.875973742"
    }


---> Sobrescrevendo o handler do proprio Spring que ja faz tratamento para
MethodArgumentNotValidException que definimos na aula anterior:

- [ANTES] O Handler criado por nós em RestExceptionHandler:

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationExceptionDetails> handleMethodArgumentNotValidException(
            MethodArgumentNotValidException exception) {
        log.info("Fields {}", exception.getBindingResult().getFieldError().getField());

        List<FieldError> fieldErrors = exception.getBindingResult().getFieldErrors();

        String fields_str = fieldErrors.stream().map(FieldError::getField).collect(Collectors.joining(", "));
        String fieldsMessage_str = fieldErrors.stream().map(FieldError::getDefaultMessage).collect(Collectors.joining(", "));

        return new ResponseEntity<>(
                ValidationExceptionDetails.builder()
                        .timestamp(LocalDateTime.now())
                        .status(HttpStatus.BAD_REQUEST.value())
                        .title("Bad Request Exception, Invalid Fields!")
                        .details("Check the field(s) error")
                        .developerMessage(exception.getClass().getName())
                        .fields(fields_str)
                        .fieldsMessage(fieldsMessage_str).build()
                , HttpStatus.BAD_REQUEST
        );
    }

- Para identificar o método que vamos sobrescrever, vamos fazer os mesmos passos:

- CTRL + Click no ResponseEntityExceptionHandler;

- CTRL + Click no retorno: "handleMethodArgumentNotValid((MethodArgumentNotValidException...":

    ...
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {

        return handleExceptionInternal(ex, null, headers, status, request);
    }

- Pronto, basta copiar a assinatura e ao invéz de retornar o handleExceptionInternal
que é genérico/polimorfico para tratar todas as instâncias de exceptions lançadas
pelo Spring MVC, verificando com if's qual instância é por meio do `instance of` e
passando para esse método os valores corretos para cada tipo de Exception:

    @ExceptionHandler({
    			HttpRequestMethodNotSupportedException.class,
    			HttpMediaTypeNotSupportedException.class,
    			HttpMediaTypeNotAcceptableException.class,
    			MissingPathVariableException.class,
    			MissingServletRequestParameterException.class,
    			ServletRequestBindingException.class,
    			ConversionNotSupportedException.class,
    			TypeMismatchException.class,
    			HttpMessageNotReadableException.class,
    			HttpMessageNotWritableException.class,
    			MethodArgumentNotValidException.class,
    			MissingServletRequestPartException.class,
    			BindException.class,
    			NoHandlerFoundException.class,
    			AsyncRequestTimeoutException.class
    		})

- [DEPOIS] Vamos deixar o método tôdo igual, mudando apenas a assinatura, e
alterando o argumento de `exception` para `ex` que vem na nova assinatura:

     protected ResponseEntity<Object> handleMethodArgumentNotValid(
        MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {
        log.info("Fields {}", ex.getBindingResult().getFieldError().getField());

        List<FieldError> fieldErrors = ex.getBindingResult().getFieldErrors();

        String fields_str = fieldErrors.stream().map(FieldError::getField).collect(Collectors.joining(", "));
        String fieldsMessage_str = fieldErrors.stream().map(FieldError::getDefaultMessage).collect(Collectors.joining(", "));

        return new ResponseEntity<>(
                ValidationExceptionDetails.builder()
                        .timestamp(LocalDateTime.now())
                        .status(HttpStatus.BAD_REQUEST.value())
                        .title("Bad Request Exception, Invalid Fields!")
                        .details("Check the field(s) error")
                        .developerMessage(ex.getClass().getName())
                        .fields(fields_str)
                        .fieldsMessage(fieldsMessage_str).build()
                , HttpStatus.BAD_REQUEST
        );
    }

- Executando POST com "name" do body Vazio "": (Mesmo cenário da aula anteior)
para verificar o MESMO método que é executado, no caso esse que sobrescrevemos
do handler do Spring MVC: (http://localhost:8080/animes?trace=true)

    {
        "title": "Bad Request Exception, Invalid Fields!",
        "status": 400,
        "details": "Check the field(s) error",
        "developerMessage": "org.springframework.web.bind.MethodArgumentNotValidException",
        "timestamp": "2023-06-14T17:19:24.900122155",
        "fields": "name",
        "fieldsMessage": "The anime name cannot be empty!"
    }

- O Retorno é o MESMO, porém agora a lógica é diferente pois sobrescrevemos o
handler do Spring MVC! podemos fazer isso para todos e assim padronizar o
tratamento das Exceptions para maior coesão do aplicativo.

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 23 - Paginação]: Annotations que resolvem esse problema,
quando temos muitos registros no retorno o ideal é retornar fragmentado..
é bem simples, basta fazer pequenas alterações e já temos esses endpoints paginados.
- O proprio JPA no Repository já tem essa funcionalidade implementada!

---> Primeira alteração é ao invés de retornar ResponseEntity<List<Anime>> alterar
para ResponseEntity<Page<Anime>> no Controller do Endpoint em questão:

- [ANTES] Retornando List ao realizar GET em localhost:8080/animes (listAll):

    @GetMapping
    public ResponseEntity<List<Anime>> list() {
        ...

        return new ResponseEntity<>(animeService.listAll(), HttpStatus.OK);
    }

- [DEPOIS] Retornando paginado, alterando o código anterior:

[src/main/java/academy/devdojo/springboot2/controller/AnimeController.java]:

    import org.springframework.data.domain.Page;
    import org.springframework.data.domain.Pageable;

                          AQUI                AQUI
    @GetMapping            \/                  \/
    public ResponseEntity<Page<Anime>> list(Pageable pageble) {
        ...                                               AQUI
                                                           \/
        return new ResponseEntity<>(animeService.listAll(pageble), HttpStatus.OK);
    }

    - Como estamos passando o pageble para o `animeService.listAll(pageble)`, logo,
    devemos também alterar para receber o argumento no Service.
    Obs: Não precisa alterar nada no Repository pois o método `listAll()` paginado vem
    do Fluxo de herança do Spring Data JPA que estendemos no Repository, logo, não
    precisamos alterar nada nele. (Mais informações abaixo).

[src/main/java/academy/devdojo/springboot2/service/AnimeService.java]:

           AQUI
            \/
    public Page<Anime> listAll(Pageable pageable) {
        ...                                  AQUI
                                              \/
        return this.animeRepository.findAll(pageable);
    }

- Pronto, só de realizar essas alterações já temos um Endpoint paginado!

- Isso é possível pois o método `findAll()` do Spring Data JPA vem da interface
`PagingAndSortingRepository<T, ID>` que implementa a paginação, esse metodo
vem do fluxo de herança:
AnimeRepository extends JpaRepository<Anime, Long>;
JpaRepository<Anime, Long> extends PagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T>;

- Para verificar isso, basta CTRL + Click no método `this.animeRepository.findAll(pageable);`
do AnimeService anterior:

[org/springframework/data/repository/PagingAndSortingRepository.class]:

    @NoRepositoryBean
    public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {
        Iterable<T> findAll(Sort var1);

        Page<T> findAll(Pageable var1);
    }

---> [RESPONSE DO JSON ANTES DAS ALTERAÇÔES]:

    [
        {
            "id": 8,
            "name": "Naruto MAPPER"
        },
        {
            "id": 9,
            "name": "Naruto MAPPER UPDATER"
        },
        {
            "id": 10,
            "name": "Naruto MAPPER UPDATER 6"
        },
        {
            "id": 12,
            "name": "Naruto MAPPER UPDATER 12"
        },
        {
            "id": 13,
            "name": "pipokinha"
        },
        {
            "id": 14,
            "name": null
        },
        {
            "id": 15,
            "name": null
        },
        {
            "id": 16,
            "name": null
        },
        {
            "id": 17,
            "name": null
        },
        {
            "id": 18,
            "name": null
        },
        {
            "id": 19,
            "name": "Pirikita"
        },
        {
            "id": 20,
            "name": null
        },
        {
            "id": 21,
            "name": null
        },
        {
            "id": 22,
            "name": "Postoide"
        },
        {
            "id": 23,
            "name": "Postoide UPDATE"
        },
        {
            "id": 24,
            "name": " "
        }
    ]

---> [RESPONSE DO JSON DEPOIS DAS ALTERAÇÔES]:

    {
        "content": [
            {
                "id": 8,
                "name": "Naruto MAPPER"
            },
            {
                "id": 9,
                "name": "Naruto MAPPER UPDATER"
            },
            {
                "id": 10,
                "name": "Naruto MAPPER UPDATER 6"
            },
            {
                "id": 12,
                "name": "Naruto MAPPER UPDATER 12"
            },
            {
                "id": 13,
                "name": "pipokinha"
            },
            {
                "id": 14,
                "name": null
            },
            {
                "id": 15,
                "name": null
            },
            {
                "id": 16,
                "name": null
            },
            {
                "id": 17,
                "name": null
            },
            {
                "id": 18,
                "name": null
            },
            {
                "id": 19,
                "name": "Pirikita"
            },
            {
                "id": 20,
                "name": null
            },
            {
                "id": 21,
                "name": null
            },
            {
                "id": 22,
                "name": "Postoide"
            },
            {
                "id": 23,
                "name": "Postoide UPDATE"
            },
            {
                "id": 24,
                "name": " "
            }
        ],
        "pageable": {
            "sort": {
                "sorted": false,
                "unsorted": true,
                "empty": true
            },
            "offset": 0,
            "pageNumber": 0,
            "pageSize": 20,
            "paged": true,
            "unpaged": false
        },
        "totalPages": 1,
        "totalElements": 16,
        "last": true,
        "size": 20,
        "number": 0,
        "sort": {
            "sorted": false,
            "unsorted": true,
            "empty": true
        },
        "first": true,
        "numberOfElements": 16,
        "empty": false
    }

- Por padrão podemos notar as seguintes informações neste JSON:

    - content é a chave da lista em questão.
    - Número máximo de elementos por página: 20 (pageable.pageSize);
    - Número total de páginas: 1 (totalPages), ou seja, apenas esse Json;
    - Número total de elementos que foi retornado: 16 (totalElements);
    - Flag que indica se é a última página: true (last);
    - Flag que indica se é a primeira página: true (first);
    ...

---> Personalizando o Response JSON da paginação deste Endpoint pelas chamadas no Frontend:

- Para indicar a quantidade de registros que deseja, podemos utilizar a seguinte URL:

    http://localhost:8080/animes?size=5 (ou http://localhost:8080/animes?size=5&page=0)

    {
        "content": [
            {
                "id": 8,
                "name": "Naruto MAPPER"
            },
            {
                "id": 9,
                "name": "Naruto MAPPER UPDATER"
            },
            {
                "id": 10,
                "name": "Naruto MAPPER UPDATER 6"
            },
            {
                "id": 12,
                "name": "Naruto MAPPER UPDATER 12"
            },
            {
                "id": 13,
                "name": "pipokinha"
            }
        ],
        "pageable": {
            "sort": {
                "sorted": false,
                "unsorted": true,
                "empty": true
            },
            "offset": 0,
            "pageNumber": 0,
            "pageSize": 5,
            "paged": true,
            "unpaged": false
        },
        "totalPages": 4,
        "totalElements": 16,
        "last": false,
        "size": 5,
        "number": 0,
        "sort": {
            "sorted": false,
            "unsorted": true,
            "empty": true
        },
        "first": true,
        "numberOfElements": 5,
        "empty": false
    }

    - Podemos notar que agora as informações são:

        - Em pageable.pageSize é indicado qual o size da página atual (5);
        - Em totalPages é indicado a quantidade de páginas (4) geradas para
        encapsular os 16 registros;
        - Em totalElements é indicado a quantidade TOTAL de registros (16)
        somados nas 4 páginas geradas;
        - Agora last aponta para false, pois ainda temos +3 páginas para iterar;

- Para NAVEGAR na próxima página gerada, utilizamos o seguinte parâmetro na chamada
do Frontend: (Lembrando que a contagem começa do 0)

    http://localhost:8080/animes?size=5&page=1

    {
        "content": [
            {
                "id": 14,
                "name": null (NÃO é erro, os registros são null mesmo)
            },
            {
                "id": 15,
                "name": null
            },
            {
                "id": 16,
                "name": null
            },
            {
                "id": 17,
                "name": null
            },
            {
                "id": 18,
                "name": null
            }
        ],
        "pageable": {
            "sort": {
                "sorted": false,
                "unsorted": true,
                "empty": true
            },
            "offset": 5,
            "pageNumber": 1,
            "pageSize": 5,
            "paged": true,
            "unpaged": false
        },
        "totalPages": 4,
        "totalElements": 16,
        "last": false,
        "size": 5,
        "number": 1,
        "sort": {
            "sorted": false,
            "unsorted": true,
            "empty": true
        },
        "first": false,
        "numberOfElements": 5,
        "empty": false
    }
