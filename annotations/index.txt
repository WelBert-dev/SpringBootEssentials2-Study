[Spring Boot Essentials 2 - Introdução ao curso.]:

- Explicações sobre o curso, 2 pois ja teve o 1, porém esse esta mais atualizado!
- Novos conteúdos (Exemplo: Criar uma imagem da aplicação e subir no docker);
- Overview geral sobre o curso

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 01 - O que é Spring Boot]:

- Criado pela galera da privaton, o intuito é criar app standalone (sem dependências, e iniciar rápidamente);
- O Framework toma conta de todas as configurações por nós, poucas configurações são delegadas a nós;
- Já vem com alguns servlet containers imbutidos (Tomcat, jetty, Undertow);
- O Springboot gerencia as dependências através dos Starters, possuindo uma integração forte com o ecossistema Spring;
- Ecossistema Spring: SpringBoot, Spring Framework, Spring Data, Spring Cloud, Spring Cloud Data Flow, Spring Security, dentre outros;
- Facilmente integrados com o SpringBoot (Basta incluir a dependencia no Maven ou Gradle) e realizar as chamadas;
- Um dos mais utilizados no mercado de trabalho, logo, temos bastante documentações e forums de discussões na web;
- O curso cobre o essencial para iniciar no mundo Spring, cobrindo pelomenos 70% das necessidades;

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 02 - Criando projeto na pedreiragem pt 01]:

- Sem utilizar o starter.io do Spring;
- Inicialmente o projeto inicia sem nada de frameworks (Maven e etc) apenas Java puro na versão 11;
- Add framework (Maven) criando assim o arquivo xml POM e a arvore de diretórios no src;
- Para o Spring gerenciar as dependências, devemos adicionar no pom:
Obs: Para funcionar, o maven deve estar configurado corretamente no projeto!

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.0</version>
    </parent>

- Após adicionado o parent, podemos adicionar as dependências:

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>

- Para verificar todas as dependências do projeto ir em:
    Botão direito na raiz do projeto > Open Module Settings (f4) > Libraries

- Obs: Adicionamos primeiro o parent para que as dependências logo abaixo herdem as versões corretas do parent!

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 03 - Criando projeto na pedreiragem pt 02]:
Dando start na aplicação Spring WEB!

    package academy.devdojo.springboot2.start;

    import org.springframework.boot.SpringApplication;

    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

Dessa forma não funciona pois não utilizamos as anotações para tornar um Bean Spring!

- Solução 01 - Mais genérica: Utilizar a annotation @EnableAutoConfiguration

    package academy.devdojo.springboot2.start;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.EnableAutoConfiguration;

    @EnableAutoConfiguration
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

Obs: Assim a aplicação inicia em 3.838 seconds, com o Quarkus podemos otimizar e reduzir drasticamente!

---> Testando criando o primeiro Endpoint: package controller!
Utilizaremos a annotation @RestController do SpringMVC para tornar AnimeController
um Bean Spring especializado em API REST (Retornos Strings Json): CTRL + Click na annotation:
- Assinatura da annotation @RestController:

    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Controller
    @ResponseBody
    public @interface RestController {
        @AliasFor(
            annotation = Controller.class
        )
        String value() default "";
    }

- A diferença entre as anotações @RestController e @Controller é que a Rest adiciona um
@ResponseBody que indica que o retorno é uma String ou seja o Objeto Json da resposta Rest!
Diferente do @Controller que é mais genérico e não especializado em respostas Json REST

- Assinatura da annotation @Controller:

    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Component
    public @interface Controller {
        @AliasFor(
            annotation = Component.class
        )
        String value() default "";
    }

---> Caso de problemas ao utilizar classes da API JAVA mais moderna, ou aumentar o language level,
ou adicionar a dependência POM:

     <properties>
        <java.version>11</java.version>
     </properties>


---> Endpoint sem contexto: Quando não anotamos em nível de classe qual será o contexto do Endpoint:
- Obs: @RequestMapping(method = RequestMethod.GET, path = "list") está defasado/obsoleto!
- Novo jeito: @GetMapping(path="list")

    // sem Contexto:
    @RestController
    public class AnimeController {

        // Sem contexto:
        //localhost:8080/list
        @RequestMapping(method = RequestMethod.GET, path = "list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Endpoint COM contexto: Quando anotamos em nível de classe:
- Add @RequestMapping("contexto") a nível de classe:

    // COM Contexto anime:
    @RestController()
    @RequestMapping("anime") // <- ADD AQUI
    public class AnimeController {

        // COM contexto:
        //localhost:8080/anime/list
        @RequestMapping(method = RequestMethod.GET, path = "list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Utilizando o jeito novo: Substituindo @RequestMapping a nível de método para @GetMapping;

    // COM Contexto anime:
    @RestController()
    @RequestMapping("anime")
    public class AnimeController {

        // COM contexto:
        //localhost:8080/anime/list
        // Defasado/obsoleto:
    //    @RequestMapping(method = RequestMethod.GET, path = "list")
        // Novo jeito elegante:
        @GetMapping(path="list")
        public List<Anime> list() {
            return List.of(new Anime("DBZ"),
                           new Anime("Berserk"));
        }
    }

---> Primeiro erro tentando acessar o Endpoint:

    Whitelabel Error Page
    This application has no explicit mapping for /error, so you are seeing this as a fallback.

    Tue May 30 14:02:32 BRT 2023
    There was an unexpected error (type=Not Found, status=404).

- Isso ocorre pois o Spring deve reconhecer TODAS as classes como um Bean para assim ele gerenciar!
- Ele reconhece isso através da hierarquia de pacotes, e se localiza pela classe "main" ApplicationStart
- Não colocamos ela na raiz, logo ele não encontra!

- Solução 01: Utilizando a anotação no ApplicationStarter.java indicando o path correto:
Utilizando o @ComponentScan(basePackages = "academy.devdojo.springboot2")

    Whitelabel Error Page
    This application has no explicit mapping for /error, so you are seeing this as a fallback.

    Tue May 30 14:13:11 BRT 2023
    There was an unexpected error (type=Internal Server Error, status=500).

- Agora o erro é outro (500): Erro de servidor, problema na serialização.
Isso ocorre geralmente por problemas de não encontrar getters and setters!
Então basta gerar os getters and setters da classe de dominio Anime (Na qual estamos gerando a List)

    [{"name":"DBZ"},{"name":"Berserk"}]

- Isso ocorre pois o Jackson que é a API especializada em Json, utiliza os métodos getters and setters
para pegar os valores e criar a response String JSON!

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 04 - @Component, @Autowired, @SpringBootApplication]:

@Autowried faz a injeção da dependência: Porém desse jeito não é recomendável por questões de segurança!
O Ideal é injetar a dependência pelos setters ou pelo construtor!
- A dependência injetada com @Autowired deve ser um Bean Spring trackeado!!
- Então devemos annotar na classe DateUtil com @Component ou Outras anotações especializadas;

    @Component
    public class DateUtil {
        ...
    }

    public class AnimeController {
        @Autowired
        private DateUtil dateUtil;
        ...
    }

- Obs: O Spring só está conseguindo trackear a classe DateUtil pois estamos escaneando tudo
apartir da raiz do projeto no ApplicationStarter.java com o
@ComponentScan(basePackages = "academy.devdojo.springboot2");
E como a classe está dentro do pacote util que está sendo trackeado, podemos realizar chamadas!

---> Movendo a classe ApplicationStarter para a raiz do projeto, assim não precisamos mais
forçar o scanner com o @ComponentScan(basePackages = "academy.devdojo.springboot2");

- Movendo para a raiz do src do projeto, não precisamos mais indicar o path no @ComponentScan()
pois ele assume como padrão o diretório em que se encontra a classe ApplicationStarter

    @EnableAutoConfiguration
    @ComponentScan
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }


---> Adicionando o Lombok no projeto para utilizar o Log4J2:
- Podemos tambem adicionar a Extensão do Lombok no projeto!

- Obs: Não indicamos a versão pois o Spring irá gerenciar isso para nós!
- Devemos habilitar na IDE o Annotation Processing;
- E se não adicionar o arquivo log4j2.xml em resources, a saída do log será apenas o valor
passado no log.info() e etc.. se quiser mais informações devemos adicionar o arquivo de
configurações log4j2.yml!! mais informações no repositório de estudos Java avançado
MaratonaJava-DevDojo no módulo JDBC (T_jdbc) aula258!
Histórico do commit com maiores detalhes:
https://github.com/WelBert-dev/MaratonaJava-DevDojo/commit/9e06ebafdac1e45420c4d6af3329041386013e80

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>


- EXEMPLO do arquivo log4j2.xml em resources:

    <?xml version="1.0" encoding="UTF-8"?>
    <Configuration status="INFO">
        <Appenders>
            <Console name="LogToConsole" target="SYSTEM_OUT">
                <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
            </Console>
        </Appenders>
        <Loggers>
            <!-- avoid duplicated logs with additivity=false -->
            <Logger name="academy.devdojo" level="info" additivity="false">
                <AppenderRef ref="LogToConsole"/>
            </Logger>
            <Root level="error">
                <AppenderRef ref="LogToConsole"/>
            </Root>
        </Loggers>
    </Configuration>


---> Podemos também realizar a injeção de dependências pelo construtor!
Basta gerar o construtor que alimente a dependência desejada, assim
o próprio container Springboot irá gerenciar e injetar a dependência,
desde que a Classe ainda esteja sendo trackeada pelo Spring sendo um Bean!

- Podemos gerar o construtor na unha e ele faz a injeção, ou também
podemos utilizar as anotações do Lombok para gerar o construtor automaticamente
e assim o Spring irá também injetar as dependências corretamente:


- @AllArgsConstructor: Cria um construtor que injeta em todos os campos;

    @AllArgsConstructor
    public class AnimeController {
        private DateUtil dateUtil;
        ...
    }

- @RequiredArgsConstructor: Cria um construtor que injeta apenas em campos finais.

    @RequiredArgsConstructor
    public class AnimeController {
        private final DateUtil dateUtil;
        ...
    }

---> Tôda aplicação Spring utiliza as anotações básicas no ApplicationStarter sendo elas:
Essas anotações formam a base para criar um app Spring, aonde uma auto configura o básico
para rodar, a outra possibilita o Spring escanear os códigos e trackear os beans e a outra
é utilizada para configurações de segurança (@Configuration) no Filter Chain;

    @EnableAutoConfiguration
    @ComponentScan
    @Configuration
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

- Então o Spring cria uma anotação que une todas essas em apenas uma sendo ela:

    @SpringBootApplication
    public class ApplicationStarter {
        public static void main(String[] args) {
            SpringApplication.run(ApplicationStarter.class, args);
        }
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 05 - Hot Swap com Spring Boot Devtools]:
Dependências do SpringBoot para tempo de desenvolvimento, otimizando tarefas
como re-bootar automaticamente o projeto ao alterar alguma classe por exemplo...
esse recurso possibilita subir a aplicação mais rápidamente.

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
    </dependency>

- Só de add essa depedência no POM ja habilita o HotSwap que faz a aplicação
executar mais rápido e re-carrega a aplicação toda vez que buildar.

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 06 - Gerando projeto com start.spring.io]:
https://start.spring.io/
- Ao invés de utilizar o schema gerado, eu deixei o meu projeto equivalente a ele!

- Add application.properties em resources;
- Ajusta POM para algumas dependẽncias só serem consideradas em tempo de desenvolvimento;

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 07 - Método GET parte 1]:

- Primeiro devemos alterar o nome do contexto no controller para o plural:

    @RequestMapping("anime") // <- AQUI vamos deixar "animes"
    @RequiredArgsConstructor
    public class AnimeController {
    ...
    }

- Também iremos remover o path do @GetMapping(path="list") pois agora ao executar GET no / do animes
ele considera esse método!

    * Antes:
    @GetMapping(path="list")
    public List<Anime> list() {
      return List.of(new Anime("DBZ"),
                     new Anime("Berserk"));
    }

    * Depois:
    @GetMapping
    public List<Anime> list() {
      return List.of(new Anime("DBZ"),
                     new Anime("Berserk"));
    }

- Também iremos retirar as regras de negócio do Controller e delegar para Service:

- Para isso primeiro vamos remover todos getters e setters, e também o construtor
da classe de dominio Anime, e adicionar a anotação @Data e @AllArgsConstructor
para gerar:
    - getters and setters;
    - equals e hashcode;
    - toString;

    @Data
    @AllArgsConstructor
    public class Anime {
        private Long id;
        private String name;
    }


---> Devemos anotar o serviço com @Service e devemos injetar a dependência do Serviço
tornando esse atributo também final para a anotação do Lombok @RequiredArgsConstructor
funcionar corretamente para esse fild também!

    @RequiredArgsConstructor // -> cria o construtor apenas para field final
    public class AnimeController {
        private final DateUtil dateUtil;
        private final AnimeService animeService; // deixamos ele como "final" também

        @GetMapping
        public List<Anime> list() {
            ...
            return animeService.listAll();
        }
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 08 - Método GET parte 2]:

- Adicionando resposta HTTP no controller com ResponseEntity<>();

    * Antes:
    @GetMapping
    public List<Anime> list() {
        ...
        return animeService.listAll();
    }

    * Depois:
    @GetMapping
    public ResponseEntity<List<Anime>> list() {
        ...
        return new ResponseEntity<>(animeService.listAll(), HttpStatus.OK);
        // return ResponseEntity.ok(animeService.listAll());
    }


---> Problemas quando temos mais de um GetMapping sem contexto:
Neste cenário o Spring não saberá qual método chamar quando rolar GET em animes:

    @GetMapping
    public ResponseEntity<List<Anime>> list() {
       ...
    }
    @GetMapping
    public ResponseEntity<Anime> findById() {
        ...
    }

- Solução: Adicionar um contexto de path variable para algum dos GET:

    @GetMapping(path="/{id}")
    public ResponseEntity<Anime> findById(@PathVariable long id) {
        ...
    }

---> Criaremos o método findById no serviço, e em casos de notFound
devemos retornar response HTTP correspondente com Throws new Exception:

     public Anime findById(long id) {
        return animeList.stream()
                .filter(anime -> anime.getId() == id)
                .findFirst()
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST,
                                                               "Anime Not Found"));
    }

---> Devemos configurar o Spring para não enviar tôdo o StackTrace em casos de Exceptions
para o Frontend:

- Primeiro devemos criar o arquivo de conf em resources:
Alterar o application.properties para application.yml
e setar:

    server:
      error:
        include-stacktrace: never // ou on_trace_param ai basta incluir ?trace=true na URL
                                  // http://localhost:8080/animes/12?trace=true

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 09 - Método POST]:
A depender do padrão adotado temos várias possibilidades de respostas para esse tipo,
por exemplo: quando o método retorna algo ou não.

- Podemos retornar um ID e retorna protocolo HTTP Status 201 CREATED;
- Podemos retornar apenas 201 CREATED e sem Body na response;
- Podemos retornar o Objeto criado inteiro ou um DTO que o represente;

---> Quando mapeamos que estamos recebendo um Json no Body da request POST,
podemos utilizar a anoatação @ e o Jackson irá mapear e converter o JSON
do body para a Entidade correspondente no Java:

    @PostMapping
    public ResponseEntity<Anime> save(@RequestBody Anime anime) {
        ...
    }

- Obs: Para que isso seja possivel as propriedades/atributos do body JSON deve ser
EXATAMENTE igual a entidade correspondente do Java! caso contrario, para os
campos que são diferentes o Jackson irá ignorar e deixar NULL!

- SOLUÇÃO para quando o JSON do body for diferente da Entidade no java:
Utilizar a anotação @JsonProperty("nome-que-vem-no-body-json")

    @Data
    @AllArgsConstructor
    public class Anime {
        private Long id;
        @JsonProperty("name") // aqui mapeamos como vem no Body JSON
        private String nameCharacter;
    }

---> Para retornar o protocolo 201 CREATED sem uma URI devemos fazer com new:

    @PostMapping
    public ResponseEntity<Anime> save(@RequestBody Anime anime) {
        ...
        return new ResponseEntity<>(animeService.save(anime), HttpStatus.CREATED);
    }

- Podemos também utilizar a anotação a nível de método:

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ResponseEntity<Anime> save(@RequestBody Anime anime) {
        ...
        return new ResponseEntity<>(animeService.save(anime), HttpStatus.CREATED);
    }

- Instalamos o POSTMAN para testar esse Endpoint! Tudo certo ;D

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 10 - Método DELETE]: NÃO FUNCIONAL AINDA LER DETALHES:
- Referência normalizada para implementações dos metodos HTTP: RFC7231
- Existem métodos Safes que são metodos que não alteram drasticamente o estado
da aplicação, esses métodas são liberados sem precisar configurar.
- DIFERENTE acontece com DELETE pois é non-safe, emtão devemos configurar
manualmente liberando esse método!! além dele o PUT também!!

- Resposta quando não tratado:

    HttpRequestMethodNotSupportedException: Request method 'DELETE' not supported

- Tabela dos métodos e seus níveis de safedade:

    +---------+------+------------+---------------+
    | Method  | Safe | Idempotent | Reference     |
    +---------+------+------------+---------------+
    | CONNECT | no   | no         | Section 4.3.6 |
    | DELETE  | no   | yes        | Section 4.3.5 |
    | GET     | yes  | yes        | Section 4.3.1 |
    | HEAD    | yes  | yes        | Section 4.3.2 |
    | OPTIONS | yes  | yes        | Section 4.3.7 |
    | POST    | no   | no         | Section 4.3.3 |
    | PUT     | no   | yes        | Section 4.3.4 |
    | TRACE   | yes  | yes        | Section 4.3.8 |
    +---------+------+------------+---------------+

- Pesquisar mais sobre Idempotent pois a depender do tipo de method HTTP em request
e se ele pode alterar o estado da aplicação, podemos ter problemas na request!

Deletando de acordo com o ID e podemos também seguir alguma convensão de retorno HTTP:

- Podemos retornar um ID e retorna protocolo HTTP Status 204 NoContent;
- Podemos retornar apenas 204 NoContent e sem Body na response;
- Podemos o Objeto deletado inteiro ou um DTO que o represente;

- OBS: ATÉ AQUI NÃO CONFIGURAMOS O MÉTODO DELETE NA API ENTÃO NÃO ESTÁ FUNCIONAAL AINDA!

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 11 - Método PUT]:
Idempotente ou seja, toda evz que executado a resposta deve ser a mesma!

- Podemos retornar um ID e retorna protocolo HTTP Status 204 NoContent;
- Podemos retornar apenas 204 NoContent e sem Body na response;
- Podemos o Objeto replaced inteiro ou um DTO que o represente;

    @PutMapping
    public ResponseEntity<Void> replace(@RequestBody Anime anime) {
        animeService.replace(anime);

        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 12 - Instalando Docker e executando container MySQL]:
- Copiei o docker-compose do projeto Maratona-Java;

1o - Criar o arquivo docker-compose.yml na raiz do projeto (configurações do container);
2o - Rodar o container: docker-compose up (obs: . deve estar no diretório do arquivo anterior .yml);
        - Caso não exista a imagem ainda, ele faz o download;

3o - Verificando se o container esta running: docker ps;
4o - Verificando TODOS containers disponíveis, até mesmo os que não estão running: docker ps -a;
5o - Removendo containers pelo docker-compose: docker-compose down;
6o - Mesmo removendo containers os volumes mapeados ainda ficam, para verificar: docker volume ls;

---> Executando comandos no container:

# Entra no container pelo shell corrente:
docker exec -it container_id bash

# Conecta com o mysql:
mysql -uroot -p

---> Adicionando dependências no projeto: pom.xml (Mysql v8.0.33)

1o - https://mvnrepository.com/artifact/mysql/mysql-connector-java > Mysql v8.0.33 Connector Java;

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>

2o - Reload Maven para baixar a dependencia adicionada acima (CTRL + SHIFT + O);

3o - Verificando se as dependências foram baixadas com sucesso: Ir na raiz > `External Libraries`;

4o - Após adicionar as dependências do mysql ao projeto, iremos criar a lógica de connection.

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 13 - Spring Data JPA pt 01]:

- Instala o JPA e o MysqlConnector (Já fiz na aula anterior sobre o mysql connector);

Mapeando automaticamente e atualizando em tempo real os schemas das tabelas
com o Spring Data JPA.

- Database: db_anime_sprinboot2

---> Adicionando dependências no projeto: pom.xml (Spring Data JPA v2.4.0)

     <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

---> Atualiza o arquivo /resources/application.yml:

    spring:
      datasource:
        url: jdbc:mysql://localhost:3306/db_anime_sprinboot2?useSSL=false&createDatabaseIsNotExists=true&allowPublicKeyRetrieval=true
        username: root
        password: root
      jpa:
        hibernate:
          ddl-auto: update

---> Transfromando o modelo de domínio Java em Entidade para mapear no banco:

- Modifica o modelo de dominio /domain/Anime.java:
    - Add a annotation em nível de classe: @Entity(name = "tbl_anime")
    - Add a annotation em nível de atributo: @Id e @GeneratedValue(strategy = GenerationType.IDENTITY)

    @Data
    @AllArgsConstructor
    @Entity(name = "tbl_anime")
    public class Anime {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;
    }

    - Resultado após executado a aplicação:
    Será criado uma tabela `tbl_anime` com o seguinte desc:

    +-------+--------------+------+-----+---------+----------------+
    | Field | Type         | Null | Key | Default | Extra          |
    +-------+--------------+------+-----+---------+----------------+
    | id    | bigint       | NO   | PRI | NULL    | auto_increment |
    | name  | varchar(255) | YES  |     | NULL    |                |
    +-------+--------------+------+-----+---------+----------------+

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 14 - Spring Data JPA pt 02]:
- Criando o AnimeRepository classe que faz as querys relacionadas a tabela Anime:
- Aonde "Long" é o tipo da primary key
- Não precisamos definir metodos pois ja estamos herdando os default (insert, update, find..)

    public interface AnimeRepository extends JpaRepository<Anime, Long> {
    }

---> Devemos atualizar todos os metodos anteriores que utilizavam DB in Memory (List);

---> Devemos criar as classes DTO correspondente para cada method http do request;

    @Data
    public class AnimePostRequestBodyDTO {
        private String name;
    }

    @Data
    public class AnimePutRequestBodyDTO {
        private Long id;
        private String name;
    }

---> Atualizar a Classe AnimeService para agora utilizar os métodos herdados do
extends JpaRepository<Anime, Long> e mapear os campos do DTO para a Entidade Java.

    @Service
    @RequiredArgsConstructor
    public class AnimeService {
        private final AnimeRepository animeRepository;
        ...
    }

    public Anime save(AnimePostRequestBodyDTO animeDTO) {
        // Mapeia o DTO para a Entidade, e ja retorna o registro com o ID

        return this.animeRepository.save(Anime.builder()
                .name(animeDTO.getName()).build());
    }

---> Atualizar a Entidade de dominio Anime para não dar problemas no Jackson:

    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor // <-- Tava dandoi erro de construtor padrão, porisso adicionei essa annotation
    @Entity(name = "tbl_anime")
    public class Anime {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        private String name;
    }

---> Pronto, agora a API esta acessando o Banco de dados Mysql nas consultas,
além de manter os schemas e registros refletidos na aplicação e no banco.

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 15 - Framework de Mapeamento MapStruct]:
- Facilitando o mapeamento de DTO's para Entidades concretas;
- Vantagem: Ele faz alguns tratamentos e validações por nós (null's e etc);
- Obs: Os campos do DTO devem ser compatíveis com a Entidade model, ou devemos
especificar com a anotação @Mapping(source = "nameDto", target = "nameEntity")
indicando qual é o campo mapeado de um para outro;

---> Adicionando dependências no projeto: pom.xml (MapStruct v1.5.5.Final):

    <properties>
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version>
    </properties>

    <dependency>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
        <version>${org.mapstruct.version}</version>
    </dependency>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>11</source> <!-- depending on your project -->
                    <target>11</target> <!-- depending on your project -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <!-- other annotation processors -->
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>

---> Criaremos um pacote separado para definição de mapeamento `mapper`:

    @Mapper(componentModel = "spring") // possibilita fazer dependency injection
    public abstract class AnimeMapper {
        public static final AnimeMapper INSTANCE = Mappers.getMapper(AnimeMapper.class);

        public abstract Anime toAnime(AnimePostRequestBodyDTO animePostRequestBodyDTO);
        public abstract Anime toAnime(AnimePutRequestBodyDTO putRequestBodyDTO);
    }

---> Realizando as chamadas no mapper ao invés de mapear manualmente:

    public Anime save(AnimePostRequestBodyDTO animePostDTO) {
        return this.animeRepository.save(AnimeMapper.INSTANCE.toAnime(animePostDTO));
    }

---> ATENÇÃO: Por adicionar as configurações de annotation proccessors do Mapper no POM
devemos também adicionar PARA TODAS as dependências que utilizam esse proccessor!!

- Neste caso devemos habilitar as annotation processor do Lombok:

    <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.8.1</version>
                    <configuration>
                        <source>11</source> <!-- depending on your project -->
                        <target>11</target> <!-- depending on your project -->
                        <annotationProcessorPaths>
                            <path>
                                <groupId>org.mapstruct</groupId>
                                <artifactId>mapstruct-processor</artifactId>
                                <version>${org.mapstruct.version}</version>
                            </path>
                            <!-- other annotation processors -->
                            <path>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok</artifactId>
                                <version>${lombok.version}</version>
                            </path>
                        </annotationProcessorPaths>
                    </configuration>
                </plugin>
            </plugins>
        </build>

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 16 - Request Params]: Parâmetros na URL ao invés do body da request

---> Primeiro iremos definir o contrato List<Anime> findByName(String name) na
interface AnimeRepository, apenas definir pois o próprio JPA irá implementar para nós!

    public interface AnimeRepository extends JpaRepository<Anime, Long> {
        List<Anime> findByName(String name);
    }

- O findByName deve corresponder com o atributo em questão da Entidade model!
- Obs: Esse find gerado pelo JPA não é com LIKE, ou seja, o valor deve ser 100%
equals (name == name);

- Para visualizar a Query gerada pelo JPA basta flaggar com `show-sql: true`
o application.yml:

    server:
      error:
        include-stacktrace: on_trace_param

    spring:
      datasource:
        url: jdbc:mysql://localhost:3306/db_anime_sprinboot2?useSSL=false&createDatabaseIsNotExists=true&allowPublicKeyRetrieval=true
        username: root
        password: root
      jpa:
        hibernate:
          ddl-auto: update
        show-sql: true // <- AQUI!!

---> Depois devemos espelhar o método na classe de Serviço:

    public List<Anime> findByName(String name) {
        return this.animeRepository.findByName(name);
    }

---> Depois iremos utilizar o serviço no Controlador:
- A anotação @RequestParam é bem parecida com a @PathVariable mas o indicado é
utilizar a @PathVariable quando não vamos passar vários params, se for passar
muitos o indicado é utilizar a RequestParam!

- A anotação @PathVariable o parâmetro é passado "seco" SEM o atributo=valor:

    @GetMapping(path = "/{id}")
    public ResponseEntity<Anime> findById(@PathVariable long id) {
       return ResponseEntity.ok(animeService.findByIdOrThrowBadRequestException(id));
    }

    - URL: http://localhost:8080/animes/2


- Já a anotação @RequestParam o parâmetro é COMPOSTO por atributo=valor:

    @GetMapping(path = "/find")
    public ResponseEntity<List<Anime>> findByName(@RequestParam String name) {
        return ResponseEntity.ok(animeService.findByName(name));
    }

    - URL: http://localhost:8080/animes/find?name=Naruto MAPPER UPDATER 12

- Assim podemos empilhar vários parâmetros da seguinte forma:

    @GetMapping(path = "/find")
    public ResponseEntity<List<Anime>> findByName(@RequestParam String name, @RequestParam String id) {
        return ResponseEntity.ok(animeService.findByName(name));
    }

    - URL: http://localhost:8080/animes/find?name=Naruto MAPPER UPDATER 12&id=12


---> Argumentos do @RequestParam:

- @RequestParam(defaultValue = ""): Valor padrão;
- @RequestParam(required = false): Obrigatório? se for, return BAD REQUEST

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 17 - Exceções Customizadas]: Criando Exceptions nas Response HTTP
- O Tratamento de Exceptions vai depender do padrão adotado pelo projeto!
- Não existe um caminho apenas, as melhores práticas é adotar um padrão para o tôdo.
- Neste contexto iremos criar uma Exception personalizada para a Response HTTP BAD REQUEST
- BadRequestException extends RuntimeException; Passando para o `super` a message do construtor;
- Para não implementar na unha o Throw, utilizaremos @ResponseStatus(HttpStatus.BAD_REQUEST)
a nível de classe na Exception customizada!
- Assim não precisamos mais utilizar o genérico em Service:

     new ResponseStatusException(HttpStatus.BAD_REQUEST,"Anime Not Found");

- Agora com a Exception customizada, a chamada/resposta será menos verboso:

    new BadRequestException("Anime Not Found");

- Vantagens: Redução de Boilerplates e possibilidades de tratamentos personalizados!

---> Primeiro iremos criar o diretório exceptions/httpRequest para centralizar essas
customizações!

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public class BadRequestException extends RuntimeException {
        public BadRequestException(String message) {
            super(message);
        }
    }

---> Depois basta substituir as chamadas no Service:

    [ANTES DE UTILIZAR A EXCEPTION CUSTOMIZADA]:

    public Anime findByIdOrThrowBadRequestException(long id) {
        return this.animeRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, // <- AQUI
                                                                "Anime Not Found"));
    }

    [DEPOIS UTILIZANDO A EXCEPTION CUSTOMIZADA]:

    public Anime findByIdOrThrowBadRequestException(long id) {
        return this.animeRepository.findById(id)
                .orElseThrow(() -> new BadRequestException("Anime Not Found")); // <- BEM MELHOR
    }

-------------------------------------------------------------------------------
[Spring Boot 2 Essentials 18 - Handler Global]: Personalizando campos do retorno
Response HTTP Exception, ou seja, configurando manualmente o método que é
executado quando lança alguma Exception relacionada ao Controller, por exemplo
HTTP BAD REQUEST que criamos anteriormente!

---> [ANTES] de personalizar, a resposta default do STATUS 400 é algo parecido com:

    {
        "timestamp": "2023-06-07T19:11:22.004+00:00",
        "status": 400,
        "error": "Bad Request",
        "message": "Anime Not Found",
        "path": "/animes/50"
    }

---> Primeiro iremos definir a classe que vai encapsular os campos personalizados
deste retorno Response HTTP de acordo com o tipo de status code (400, 404 e etc)
ou também podemos definir um genérico para todos, ou para um grupo seleto de status
code em casos de campos similares ou iguais. (Utilizar o conceito de herança).

- Iremos definir a classe no mesmo pacote do BadRequestException personalziado anterior.
- Boas práticas de nomeclatura: TipoExceptionHTTPDetails: BadRequestExceptionDetails

    @Data
    @Builder
    public class BadRequestExceptionDetails {
        private String title;
        private int status;
        private String details;
        private String developerMessage;
        private LocalDateTime timestamp;
        private String camposDoRetornoPersonalizado;
    }

- Após definir devemos indicar para todos os Controllers que desejamos utilizar ela
toda vez que lançar uma Exception do tipo BadRequestException que criamos anteriormente!

---> Devemos criar um pacote centralizado para essas configurações:
handler/exceptions/httpRequest

- A Classe será definida para lidar com qualquer request REST: RestExceptionHandler
- Nesta classe de configuração iremos anotar a nível de classe com @ControllerAdvice
para indicar ao Spring que está classe deve ser considerada no controlador para lidar
com alguns cenários, esses cenários deveram ser "flaggados", ou seja, vamos utilizar
outras anotações em nível de métodos paar indicar quais os cenários ele deve chamar
esses métodos personalizados.
- A Anotação que vamos utilizar para definir o cenário em que o Controller deve chamar
o método definido por nós para tratar as Exceptions do tipo BadRequestException criado
por nós anteriormente, e executar esse método toda vez que lançado ela, é a annotation
@ExceptionHandler(BadRequestException.class):

    @ControllerAdvice
    public class RestExceptionHandler {

        @ExceptionHandler(BadRequestException.class)
        public ResponseEntity<BadRequestExceptionDetails> handlerBadRequestException(BadRequestException bre) {
            return new ResponseEntity<>(
                    BadRequestExceptionDetails.builder()
                            .timestamp(LocalDateTime.now())
                            .status(HttpStatus.BAD_REQUEST.value())
                            .title("Bad Request Exception, Check the documentation!")
                            .details(bre.getMessage())
                            .developerMessage(bre.getClass().getName())
                            .camposDoRetornoPersonalizado("HANDLER PERSONALIZADOOO! ;D").build()
                    , HttpStatus.BAD_REQUEST
            );
        }
    }

---> [RESULTADO] (Toda vez que lançar a exception BadRequestException criadas por
nós anteriormente, será chamado esse método:
- Obs: Fiz a mesma requisição que gerou o Response da seção "[ANTES] " logo a cima /\

    {
        "title": "Bad Request Exception, Check the documentation!",
        "status": 400,
        "details": "Anime Not Found",
        "developerMessage": "academy.devdojo.springboot2.exceptions.httpRequest.BadRequestException",
        "timestamp": "2023-06-07T16:42:45.408296358",
        "camposDoRetornoPersonalizado": "HANDLER PERSONALIZADOOO! ;D"
    }